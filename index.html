<!DOCTYPE html>
<html>
  <head>
    <title>Pointer Events</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove' defer></script>
    <script class='remove'>
      var respecConfig = {
          specStatus:           "ED",
          shortName:            "pointerevents3",
          subtitle: "Level 3",
          edDraftURI:           "https://w3c.github.io/pointerevents/",
          prevRecShortname: 'pointerevents',
          github: "https://github.com/w3c/pointerevents/",
          testSuiteURI: "https://wpt.fyi/pointerevents/",
          caniuse: "pointer",
          formerEditors:  [
              { name: "Matt Brubeck",
                company: "Mozilla", companyURL: "https://www.mozilla.org/",
                w3cid: '45617' },
              { name: "Rick Byers",
                company: "Google", companyURL: "https://www.google.com/" ,
                w3cid: '55724' },
          ],
          editors:  [
              { name: "Patrick H. Lauke",
                company: "TetraLogical", companyURL: "https://tetralogical.com/",
                w3cid: '35129' },
              { name: "Navid Zolghadr",
                company: "Google", companyURL: "https://www.google.com/" ,
                w3cid: '92361' },
          ],
          group: "pointer-events",
          wgPublicList: "public-pointer-events",
          lint: {
            "check-punctuation": true,
          },
          noIDLSorting:         true,
          doJsonLd: true,
          xref: {
            specs: ["uievents"],
            profile: "web-platform",
          },
          mdn: "pointerevents",
        };
    </script>
    <style>
        .issue {background: #fcc !important;}
        pre.idl::before, pre.example::before { font-family: sans-serif !important; }
        ol:not([data-class='note-list'])>li { margin-bottom: 1em; }
    </style>
  </head>
  <body>
    <section id='abstract'>
        <p>The features in this specification extend or modify those found in Pointer Events, a W3C Recommendation that describes events and related interfaces for handling hardware agnostic pointer input from devices including a mouse, pen, touchscreen, etc. For compatibility with existing mouse based content, this specification also describes a mapping to fire Mouse Events for other pointer device types.</p>
    </section>

    <section id="sotd">
        <p>This specification is an update to [[PointerEvents2]] which was shipped broadly by Google Chrome and Microsoft Edge and Mozilla Firefox.
           Level 3 includes editorial clarifications and new features that facilitate more use cases, in an effort to enable wider developer and browser adoption.</p>
    </section>

    <section id="intro" class="informative">
        <h1>Introduction</h1>
        <p>Today, most [[HTML]] content is used with and/or designed for mouse input.  Those that handle input in a custom manner typically code to [[UIEVENTS]] Mouse Events. Newer computing devices today, however, incorporate other forms of input, including touchscreens, pen input, etc. Event types have been proposed for handling each of these forms of input individually. However, that approach often incurs unnecessary duplication of logic and event handling overhead when adding support for a new input type. This often creates a compatibility problem when content is written with only one device type in mind. Additionally, for compatibility with existing mouse-based content, most <a data-lt="user agent">user agents</a> fire Mouse Events for all input types. This makes it ambiguous whether a Mouse Event represents an actual mouse device or is being produced from another input type for compatibility, which makes it hard to code to both device types simultaneously.</p>

        <p>To reduce the cost of coding to multiple input types and also to help with the above described ambiguity with Mouse Events, this specifications defines a more abstract form of input, called a <a>pointer</a>. A pointer can be any point of contact on the screen made by a mouse cursor, pen, touch (including multi-touch), or other pointing input device. This model makes it easier to write sites and applications that work well no matter what hardware the user has. For scenarios when device-specific handling is desired, this specification also defines properties for inspecting the device type which produced the event. The primary goal is to provide a single set of events and interfaces that allow for easier authoring for cross-device pointer input while still allowing for device-specific handling only when necessary for an augmented experience.</p>
        <p>An additional key goal is to enable multi-threaded user agents to handle <a>direct manipulation</a> actions for panning and zooming (for instance, with a finger or stylus on a touchscreen), without blocking on script execution.</p>

        <div class="note">
            <p>While this specification defines a unified event model for a variety of pointer inputs, this model does not cover other forms of input such as keyboards or keyboard-like interfaces (for instance, a screen reader or similar assistive technology running on a touchscreen-only device, which allows users sequential navigation through focusable controls and elements). While user agents might choose to also generate pointer events in response to these interfaces, this scenario is not covered in this specification.</p>

            <p>In the first instance, authors are encouraged to provide equivalent functionality for all forms of input by responding to high-level events such as <code>focus</code>, <code>blur</code> and <code>click</code>. However, when using low-level events (such as Pointer Events), authors are encouraged to ensure that all types of input are supported. In the case of keyboards and keyboard-like interfaces, this might require the addition of explicit keyboard event handling. See <a href="https://www.w3.org/TR/WCAG/#keyboard-accessible"><cite><abbr title="Web Content Accessibility Guidelines">WCAG</abbr> Guideline 2.1 Keyboard Accessible</cite></a> [[WCAG21]] for further details.</p>
        </div>

        <figure id="figure_martini_glass">
            <img src="images/pointer.png" alt="Pointer input combines input from mouse, pen, touch, etc.">
            <figcaption>A pointer is a hardware agnostic representation of input devices that can target a specific coordinate (or set of coordinates) on a screen.</figcaption>
        </figure>

        <p>The events for handling generic pointer input look a lot like those for mouse: <code>pointerdown</code>, <code>pointermove</code>, <code>pointerup</code>, <code>pointerover</code>, <code>pointerout</code>, etc. This facilitates easy content migration from Mouse Events to Pointer Events.
        Pointer Events provide all the usual properties present in Mouse Events (client coordinates, target element, button states, etc.) in addition to new properties for other forms of input: pressure, contact geometry, tilt, etc. So authors can easily code to Pointer Events to share logic between different input types where it makes sense, and customize for a particular type of input only where necessary to get the best experience.</p>
        <p>While Pointer Events are sourced from a variety of input devices, they are not defined as being generated from some other set of device-specific events. While possible and encouraged for compatibility, this spec does not require other device-specific events be supported (e.g. mouse events, touch events, etc.).  A user agent could support pointer events without supporting any other device events. For compatibility with content written to mouse-specific events, this specification does provide an optional section describing how to generate <a>compatibility mouse events</a> based on pointer input from devices other than a mouse.</p>

        <div class="note informative">
            <p>This specification does not provide any advice on the expected behavior of user agents that support both Touch Events (as defined in [[TOUCH-EVENTS]]) and Pointer Events. For more information on the relationship between these two specifications, see the <a href="http://www.w3.org/community/touchevents/">Touch Events Community Group</a>.</p>
        </div>

    </section>

    <section id="conformance">
    </section>

    <section class="informative">
        <h1>Examples</h1>
        <p>The following are basic examples that demonstrates how some of the APIs in this specification might be used by authors. Further, more specific examples are provided in the relevant sections of this document.</p>
<pre id="example_1" class="example" title="Feature detection and event binding">
<code>/* Bind to either Pointer Events or traditional touch/mouse */

if (window.PointerEvent) {
    // if Pointer Events are supported, only listen to pointer events
    target.addEventListener("pointerdown", function(e) {
        // if necessary, apply separate logic based on e.pointerType
        // for different touch/pen/mouse behavior
        ...
    });
    ...
} else {
    // traditional touch/mouse event handlers
    target.addEventListener('touchstart', function(e) {
        // prevent compatibility mouse events and click
        e.preventDefault();
        ...
    });
    ...
    target.addEventListener('mousedown', ...);
    ...
}

// additional event listeners for keyboard handling
...</code>
</pre>
<pre id="example_2" class="example" title="Detecting the type of input from a user">
<code>window.addEventListener("pointerdown", detectInputType);

function detectInputType(event) {
    switch(event.pointerType) {
        case "mouse":
            /* mouse input detected */
            break;
        case "pen":
            /* pen/stylus input detected */
            break;
        case "touch":
            /* touch input detected */
            break;
        default:
            /* pointerType is empty (could not be detected)
            or UA-specific custom type */
    }
}</code></pre>

<pre id="example_3" class="example" title="Resizing an element to match the contact geometry">
<code>&lt;div style="position:absolute; top:0px; left:0px; width:100px;height:100px;"&gt;&lt;/div&gt;
&lt;script&gt;
window.addEventListener("pointerdown", checkPointerSize);

function checkPointerSize(event) {
    event.target.style.width = event.width + "px";
    event.target.style.height = event.height + "px";
}
&lt;/script&gt;</code>
</pre>
<pre id="example_4" class="example" title="Firing untrusted pointer events from script">
<code>const event1 = new PointerEvent("pointerover",
  { bubbles: true,
    cancelable: true,
    composed: true,
    pointerId: 42,
    pointerType: "pen",
    clientX: 300,
    clientY: 500
  });
eventTarget.dispatchEvent(event1);

let pointerEventInitDict =
{
  bubbles: true,
  cancelable: true,
  composed: true,
  pointerId: 42,
  pointerType: "pen",
  clientX: 300,
  clientY: 500,
};
const p1 = new PointerEvent("pointermove", pointerEventInitDict);
pointerEventInitDict.clientX += 10;
const p2 = new PointerEvent("pointermove", pointerEventInitDict);
pointerEventInitDict.coalescedEvents = [p1, p2];
const event2 = new PointerEvent("pointermove", pointerEventInitDict);
eventTarget.dispatchEvent(event2);</code>
</pre>
    </section>

    <section>
        <h1>Pointer Events and interfaces</h1>
        <section>
            <h2><code>PointerEvent</code> interface</h2>
            <div>
              <pre class="idl">
dictionary PointerEventInit : MouseEventInit {
    long        pointerId = 0;
    double      width = 1;
    double      height = 1;
    float       pressure = 0;
    float       tangentialPressure = 0;
    long        tiltX;
    long        tiltY;
    long        twist = 0;
    double      altitudeAngle;
    double      azimuthAngle;
    DOMString   pointerType = "";
    boolean     isPrimary = false;
    sequence&lt;PointerEvent> coalescedEvents = [];
    sequence&lt;PointerEvent> predictedEvents = [];
};

[Exposed=Window]
interface PointerEvent : MouseEvent {
    constructor(DOMString type, optional PointerEventInit eventInitDict = {});
    readonly        attribute long        pointerId;
    readonly        attribute double      width;
    readonly        attribute double      height;
    readonly        attribute float       pressure;
    readonly        attribute float       tangentialPressure;
    readonly        attribute long        tiltX;
    readonly        attribute long        tiltY;
    readonly        attribute long        twist;
    readonly        attribute double      altitudeAngle;
    readonly        attribute double      azimuthAngle;
    readonly        attribute DOMString   pointerType;
    readonly        attribute boolean     isPrimary;
    [SecureContext] sequence&lt;PointerEvent> getCoalescedEvents();
    sequence&lt;PointerEvent> getPredictedEvents();
};
              </pre>
                <dl data-dfn-for="PointerEvent" data-link-for="PointerEvent">
                    <dt><dfn>pointerId</dfn></dt>
                        <dd>
                            <p>A unique identifier for the pointer causing the event. This identifier MUST be unique from all other <a data-lt="active pointer">active pointers</a> in the <a>top-level browsing context</a> (as defined by [[HTML]]) at the time. The <code>pointerId</code> value of <code>-1</code> is reserved to indicate events that were generated by something other than a pointing device. A user agent MAY recycle previously retired values for <code>pointerId</code> from previous active pointers, if necessary.</p>

                            <div class="note">
                                <p>The <code>pointerId</code> selection algorithm is implementation specific. Therefore authors cannot assume values convey any particular meaning other than an identifier for the pointer that is unique from all other active pointers. As an example, user agents may simply assign a number, starting from <code>1</code>, to any active pointers, in the order that they become active - but these values are not guaranteed to be monotonically increasing. Other user agents may opt to assign a completely randomized and unique number to each active pointer. However, in the latter scenarios user agents MUST ensure that the <code>pointerId</code> that is assigned remains the same only for the lifetime of the current page, and that any new <code>pointerId</code> values are not predictable (e.g. generated randomly with cryptographically strong randomness), to minimize the possibility of users being uniquely fingerprinted and tracked across different pages.</p>
                            </div>
                        </dd>
                    <dt><dfn>width</dfn></dt>
                        <dd>
                            <p>The width (magnitude on the X axis), in CSS pixels (see [[CSS21]]), of the <a>contact geometry</a> of the pointer.  This value MAY be updated on each event for a given pointer. For inputs that typically lack contact geometry (such as a traditional mouse), and in cases where the actual geometry of the input is not detected by the hardware, the <a>user agent</a> MUST return a default value of 1.</p>
                        </dd>
                    <dt><dfn>height</dfn></dt>
                        <dd>
                            <p>The height (magnitude on the Y axis), in CSS pixels (see [[CSS21]]), of the <a>contact geometry</a> of the pointer.  This value MAY be updated on each event for a given pointer. For inputs that typically lack contact geometry (such as a traditional mouse), and in cases where the actual geometry of the input is not detected by the hardware, the <a>user agent</a> MUST return a default value of 1.</p>
                        </dd>
                    <dt><dfn>pressure</dfn></dt>
                        <dd>
                            <p>The normalized pressure of the pointer input in the range of [0,1], where 0 and 1 represent the minimum and maximum pressure the hardware is capable of detecting, respectively. For hardware and platforms that do not support pressure, the value MUST be 0.5 when in the <a>active buttons state</a> and 0 otherwise. Note: all <code>pointerup</code> events will have pressure 0.</p>
                        </dd>
                    <dt><dfn>tangentialPressure</dfn></dt>
                        <dd>
                          <p>The normalized tangential pressure (also known as barrel pressure), typically set by an additional control (e.g. a finger wheel on an airbrush stylus), of the pointer input in the range of [-1,1], where 0 is the neutral position of the control. Note that some hardware may only support positive values in the range of [0,1]. For hardware and platforms that do not support tangential pressure, the value MUST be 0.</p>
                        </dd>
                    <dt><dfn>tiltX</dfn></dt>
                        <dd>
                            <p>The plane angle (in degrees, in the range of [-90,90]) between the Y-Z plane and the plane containing both the transducer (e.g. pen/stylus) axis and the Y axis. A positive <code>tiltX</code> is to the right. <code>tiltX</code> can be used along with <code>tiltY</code> to represent the tilt away from the normal of a transducer with the digitizer. For hardware and platforms that do not report tilt or angle, the value MUST be 0.</p>
                            <figure id="figure_tiltX">
                                <img src="images/tiltX_600px.png" alt="tiltX explanation diagram">
                                <figcaption>Positive <code>tiltX</code>.</figcaption>
                            </figure>
                        </dd>
                    <dt><dfn>tiltY</dfn></dt>
                        <dd>
                            <p>The plane angle (in degrees, in the range of [-90,90]) between the X-Z plane and the plane containing both the transducer (e.g. pen/stylus) axis and the X axis. A positive <code>tiltY</code> is towards the user. <code>tiltY</code> can be used along with <code>tiltX</code> to represent the tilt away from the normal of a transducer with the digitizer. For hardware and platforms that do not report tilt or angle, the value MUST be 0.</p>
                            <figure id="figure_tiltY">
                                <img src="images/tiltY_600px.png" alt="tiltY explanation diagram">
                                <figcaption>Negative <code>tiltY</code>.</figcaption>
                            </figure>
                        </dd>
                    <dt><dfn>twist</dfn></dt>
                        <dd>
                            <p>The clockwise rotation (in degrees, in the range of [0,359]) of a transducer (e.g. pen/stylus) around its own major axis. For hardware and platforms that do not report twist, the value MUST be 0.</p>
                        </dd>
                    <dt><dfn>altitudeAngle</dfn></dt>
                        <dd>
                            <p>The altitude (in radians) of the transducer (e.g. pen/stylus), in the range [0,π/2] - where 0 is parallel to the surface (X-Y plane), and π/2 is perpendicular to the surface. For hardware and platforms that do not report tilt or angle, the value MUST be π/2.</p>
                            <div class="note">
                                When the hardware or platform does not report the tilt or angle, as opposed to the default value of 0 defined for <code>altitudeAngle</code>
                                in <a href="https://w3c.github.io/touch-events/">Touch Events - Level 2</a> specification,
                                the default value defined here is π/2. This correlates with the default values of 0 for both <code>tiltX</code> and
                                <code>tiltY</code> (when the hardware or platform do not report them) which positions the transducer as being perpendicular to the surface.
                            </div>
                            <figure id="figure_altitudeAngle">
                                <img src="images/altitudeAngle.png" alt="altitudeAngle explanation diagram">
                                <figcaption>Example <code>altitudeAngle</code> of π/4 (45 degrees from the X-Y plane).</figcaption>
                            </figure>
                        </dd>
                    <dt><dfn>azimuthAngle</dfn></dt>
                        <dd>
                            <p>The azimuth angle (in radians) of the transducer (e.g. pen/stylus), in the range [0, 2π] - where 0 represents a transducer whose cap is pointing in the direction of increasing X values (point to "3 o'clock" if looking straight down) on the X-Y plane, and the values progressively increase when going clockwise (π/2 at "6 o'clock", π at "9 o'clock", 3π/2 at "12 o'clock"). When the transducer is perfectly perpendicular to the surface (<code>altitudeAngle</code> of π/2), the value MUST be 0. For hardware and platforms that do not report tilt or angle, the value MUST be 0.</p>
                            <figure id="figure_azimuthAngle">
                                <img src="images/azimuthAngle.png" alt="azimuthAngle explanation diagram">
                                <figcaption>Example <code>azimuthAngle</code> of π/6 ("4 o'clock").</figcaption>
                            </figure>
                        </dd>
                    <dt><dfn>pointerType</dfn></dt>
                        <dd>
                            <p>Indicates the device type that caused the event (mouse, pen, touch, etc.). If a user agent is to <a>fire a pointer event</a> for a mouse, pen/stylus, or touch input device, then the value of <code>pointerType</code> MUST be according to the following table:</p>
                            <table class="simple">
                                <thead>
                                    <tr><th>Pointer Device Type</th><th><code>pointerType</code> Value</th></tr>
                                </thead>
                                <tbody>
                                    <tr><td>Mouse</td><td><code>mouse</code></td></tr>
                                    <tr><td>Pen / stylus</td><td><code>pen</code></td></tr>
                                    <tr><td>Touch contact</td><td><code>touch</code></td></tr>
                                </tbody>
                            </table>
                            <p>If the device type cannot be detected by the user agent, then the value MUST be an empty string. If a user agent supports pointer device types other than those listed above, the value of <code>pointerType</code> SHOULD be vendor prefixed to avoid conflicting names for different types of devices. Future specifications MAY provide additional normative values for other device types.</p>
                          <div class="note">See <a href="#example_2" title="examples">Example 2</a> for a basic demonstration of how the <code>pointerType</code> can be used. Also note that developers should include some form of default handling to cover user agents that may have implemented their own custom <code>pointerType</code> values and for situations where <code>pointerType</code> is simply an empty string.</div>
                        </dd>
                    <dt><dfn>isPrimary</dfn></dt>
                        <dd>
                            <p>Indicates if the pointer represents the <a>primary pointer</a> of this pointer type.</p>
                        </dd>
                     <dt><dfn>getCoalescedEvents()</dfn> method</dt>
                        <dd>
                            <p>A method that returns the list of <a>coalesced events</a>.</p>
                        </dd>
                     <dt><dfn>getPredictedEvents()</dfn> method</dt>
                        <dd>
                            <p>A method that returns the list of <a>predicted events</a>.</p>
                        </dd>
                </dl>

                <p>The <dfn>PointerEventInit</dfn> dictionary is used by the <dfn>PointerEvent</dfn> interface's constructor to provide a mechanism by which to construct untrusted (synthetic) pointer events. It inherits from the {{MouseEventInit}} dictionary defined in [[UIEVENTS]]. The [=event constructing steps=] are defined in the [[[DOM]]]. See the <a href="#examples" title="examples">examples</a> for sample code demonstrating how to fire an untrusted pointer event.</p>

                <div class="note">
                    <p>Pointer Events include two complementary sets of attributes to express the orientation of a
                    transducer relative to the X-Y plane: <code>tiltX</code> / <code>tiltY</code>
                    (introduced in the original Pointer Events specification), and
                    <code>azimuthAngle</code> / <code>altitudeAngle</code>
                    (adopted from the <a href="https://w3c.github.io/touch-events/">Touch Events - Level 2</a> specification).
                    Implementations SHOULD provide both sets of attributes for trusted events.</p>
                    <p>When an untrusted (synthetic) Pointer Event is created programmatically using the constructor,
                    and only one set of attributes is provided, the complementary set of attributes SHOULD be calculated and
                    initialized by the user agent. If both sets of attributes are provided, no calculation should be performed.
                    If only the value of one of the two attributes is provided, the other attribute SHOULD be initialized to
                    the default value.</p>
                    <p>When the user agent calculates <code>tiltX</code> / <code>tiltY</code> from
                    <code>azimuthAngle</code> / <code>altitudeAngle</code> it SHOULD round the final integer values using
                    <a data-cite="ECMASCRIPT#sec-math.round">Math.round</a> [[ECMASCRIPT]] rules.</p>
                </div>

                <div class="note">The <code>PointerEvent</code> interface inherits from {{MouseEvent}}, defined in [[[UIEVENTS]]] and extended by [[[CSSOM-VIEW]]].</div>
            </div>
            <section>
                <h2>Button states</h2>
                <section>
                    <h3><dfn>Chorded button interactions</dfn></h3>
                    <p>Some pointer devices, such as mouse or pen, support multiple buttons. In the [[UIEVENTS]] Mouse Event model, each button press produces a <code>mousedown</code> and <code>mouseup</code> event.  To better abstract this hardware difference and simplify cross-device input authoring, Pointer Events do not fire overlapping <code>pointerdown</code> and <code>pointerup</code> events for <a data-lt="Chorded Button Interactions">chorded button presses</a> (depressing an additional button while another button on the pointer device is already depressed).</p>
                    <p>Instead, chorded button presses can be detected by inspecting changes to the <code>button</code> and <code>buttons</code> properties. The <code>button</code> and <code>buttons</code> properties are inherited from the {{MouseEvent}} interface, but with a change in semantics and values, as outlined in the following sections.</p>
                    <div class="note">The modifications to the <code>button</code> and <code>buttons</code> properties apply only to pointer events. For any <a>compatibility mouse events</a> the value of <code>button</code> and <code>buttons</code> should follow [[UIEVENTS]].</div>
                </section>
                <section>
                    <h3>The <code>button</code> property</h3>
                    <p>To identify button state transitions in any pointer event (and not just <code>pointerdown</code> and <code>pointerup</code>), the <code>button</code> property indicates the device button whose state-change fired the event.</p>
                    <table class="simple">
                        <thead><tr><th>Device Button Changes</th><th><code>button</code></th></tr></thead>
                        <tbody>
                            <tr><td>Neither buttons nor touch/pen contact changed since last event</td><td>-1</td></tr>
                            <tr><td>Left Mouse,<br>Touch contact,<br>Pen contact</td><td>0</td></tr>
                            <tr><td>Middle Mouse</td><td>1</td></tr>
                            <tr><td>Right Mouse,<br>Pen barrel button</td><td>2</td></tr>
                            <tr><td>X1 (back) Mouse</td><td>3</td></tr>
                            <tr><td>X2 (forward) Mouse</td><td>4</td></tr>
                            <tr><td>Pen eraser button</td><td>5</td></tr>
                        </tbody>
                    </table>
                    <div class="note">During a mouse drag, the value of the <code>button</code> property in a <code>pointermove</code> event will be different from that in a <code>mousemove</code> event. For example, while moving the mouse with the right button pressed, the <code>pointermove</code> events will have the <code>button</code> value -1, but the <code>mousemove</code> events will have the <code>button</code> value 2.</div>
                </section>
                <section>
                    <h3>The <code>buttons</code> property</h3>
                    <p>The <code>buttons</code> property gives the current state of the device buttons as a bitmask (same as in <code>MouseEvent</code>, but with an expanded set of possible values).</p>
                    <table class="simple">
                        <thead><tr><th>Current state of device buttons</th><th><code>buttons</code></th></tr></thead>
                        <tbody>
                            <tr><td><strong>Mouse moved with no buttons pressed</strong>,<br> Pen moved while hovering with no buttons pressed</td><td>0</td></tr>
                            <tr><td>Left Mouse,<br>Touch contact,<br>Pen contact</td><td>1</td></tr>
                            <tr><td>Middle Mouse</td><td>4</td></tr>
                            <tr><td>Right Mouse,<br>Pen barrel button</td><td>2</td></tr>
                            <tr><td>X1 (back) Mouse</td><td>8</td></tr>
                            <tr><td>X2 (forward) Mouse</td><td>16</td></tr>
                            <tr><td>Pen eraser button</td><td>32</td></tr>
                        </tbody>
                    </table>
                </section>
            </section>
            <section>
                <h2>The <dfn>primary pointer</dfn></h2>
                <p>In a multi-pointer (e.g. multi-touch) scenario, the <code>isPrimary</code> property is used to identify a master pointer amongst the set of <a data-lt="active pointer">active pointers</a> for each pointer type.</p>
                <ul>
                    <li>At any given time, there can only ever be at most one primary pointer for each pointer type.</li>
                    <li>The first pointer to become active for a particular pointer type (e.g. the first finger to touch the screen in a multi-touch interaction) becomes the primary pointer for that pointer type.</li>
                    <li>Only a primary pointer will produce <a>compatibility mouse events</a>. In the case where there are multiple <a data-lt="Primary Pointer">primary pointers</a>, these pointers will all produce <a>compatibility mouse events</a>.</li>
                </ul>
                <div class="note">Authors who desire single-pointer interaction can achieve this by ignoring non-primary pointers (however, see the note below on <a href="#multiple-primary-pointers">multiple primary pointers</a>).</div>
                <div class="note" id="multiple-primary-pointers">When two or more pointer device types are being used concurrently, multiple pointers (one for each <code>pointerType</code>) are considered primary. For example, a touch contact and a mouse cursor moved simultaneously will produce pointers that are both considered primary.</div>
                <div class="note">Some devices, operating systems and user agents may ignore the concurrent use of more than one type of pointer input to avoid accidental interactions. For instance, devices that support both touch and pen interactions may ignore touch inputs while the pen is actively being used, to allow users to rest their hand on the touchscreen while using the pen (a feature commonly referred to as "palm rejection"). Currently, it is not possible for authors to suppress this behavior.</div>
                <div class="note">In some cases, it is possible for the user agent to fire pointer events in which no pointer is marked as a primary pointer. For instance, when there are multiple active pointers of a particular type, like a multi-touch interaction, and the primary pointer is removed (e.g. it leaves the screen), there may end up being no primary pointers. Also on platforms where the primary pointer is determined using all active pointers of the same type on the device (including those targeted at an application other than the user agent), if the first (primary) pointer is outside of the user agent and other (non-primary) pointers targeted inside the user agent, then the user agent may fire pointer events for the other pointers with a value of <code>false</code> for <code>isPrimary</code>.</div>
                <div class="note" id="multiple-mouse-inputs">Current operating systems and user agents don't usually have a concept of multiple mouse inputs. When more than one mouse device is present (for instance, on a laptop with both a trackpad and an external mouse), all mouse devices are generally treated as a single device - movements on any of the devices are translated to movement of a single mouse pointer, and there is no distinction between button presses on different mouse devices. For this reason, there will usually only be a single mouse pointer, and that pointer will be primary.</div>
            </section>

            <section>
                <h2>Firing events using the <code>PointerEvent</code> interface</h2>
                <p>To <dfn>fire a pointer event</dfn> named |e| means to [=fire an event=] named |e| using <a>PointerEvent</a> whose attributes are set as defined in {{PointerEvent}} Interface and <a href="#attributes-and-default-actions">Attributes and Default Actions</a>.</p>
                <p>If the event is not <code>gotpointercapture</code> or <code>lostpointercapture</code>, run <a href="#process-pending-pointer-capture">Process Pending Pointer Capture</a> steps for this <code>PointerEvent</code>.

                <p>The target object at which the event is fired is determined as follows:
                <ul>
                    <li>If the <a>pointer capture target override</a> has been set for the pointer, set the target to <a>pointer capture target override</a> object.</li>
                    <li>Otherwise, set the target to the object returned by normal hit test mechanisms (out of scope for this specification).</li>
                </ul>

                <p>Let |targetDocument| be target's [=Node/node document=] [[DOM]].

                <p>If the event is <code>pointerdown</code>, <code>pointermove</code>, or <code>pointerup</code> set <a>active document</a> for the event's <code>pointerId</code> to |targetDocument|.</p>

                <p>If the event is <code>pointerdown</code>, the associated device is a direct manipulation device, and the target is an {{Element}},
                   then <a href="#setting-pointer-capture">set pointer capture</a> for this <code>pointerId</code> to the target element as described in <a>implicit pointer capture</a>.

                <p>Fire the event to the determined target.

                <div class="note">Using the <a>pointer capture target override</a> as the target instead of the normal hit-test result may fire some boundary events. This is the same as the pointer leaving its previous target and entering this new capturing target - and if they are different targets, boundary events should be dispatched first. When the capture is released, the same scenario may happen, as the pointer is leaving the capturing target and entering the hit-test target.</div>

                <section>
                  <h3>Attributes and default actions</h3>
                        <p>The <code>bubbles</code> and <code>cancelable</code> properties and the default actions for the event types defined in this specification appear in the following table. Details of each of these event types are provided in <a href="#pointer-event-types">Pointer Event types</a>.</p>
                        <table id="pointer-event-type-table" class="simple">
                            <thead><tr>
                                <th>Event Type</th><th>Bubbles</th><th>Cancelable</th><th>Default Action</th></tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><code>pointerover</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>None</td>
                                </tr>
                                <tr>
                                    <td><code>pointerenter</code></td>
                                    <td>No</td>
                                    <td>No</td>
                                    <td>None</td>
                                </tr>
                                <tr>
                                    <td><code>pointerdown</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Varies: when the pointer is primary, all default actions of the <code>mousedown</code> event
                                        <br>Canceling this event also sets the <code>PREVENT MOUSE EVENT</code> flag for this <code>pointerType</code>, which prevents subsequent firing of certain <a>compatibility mouse events</a>.</td>
                                </tr>
                                <tr>
                                    <td><code>pointermove</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Varies:  when the pointer is primary, all default actions of <code>mousemove</code></td>
                                </tr>
                                <tr>
                                    <td><code>pointerup</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>Varies:  when the pointer is primary, all default actions of <code>mouseup</code></td>
                                </tr>
                                <tr>
                                    <td><code>pointercancel</code></td>
                                    <td>Yes</td>
                                    <td>No</td>
                                    <td>None</td>
                                </tr>
                                <tr>
                                    <td><code>pointerout</code></td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>None</td>
                                </tr>
                                <tr>
                                    <td><code>pointerleave</code></td>
                                    <td>No</td>
                                    <td>No</td>
                                    <td>None</td>
                                </tr>
                                <tr>
                                    <td><code>gotpointercapture</code></td>
                                    <td>Yes</td>
                                    <td>No</td>
                                    <td>None</td>
                                </tr>
                                <tr>
                                    <td><code>lostpointercapture</code></td>
                                    <td>Yes</td>
                                    <td>No</td>
                                    <td>None</td>
                                </tr>
                            </tbody>
                        </table>

                        <p>Viewport manipulations (panning and zooming) - generally, as a result of a <a>direct manipulation</a> interaction - are intentionally NOT a default action of pointer events, meaning that these behaviors (e.g. panning a page as a result of moving a finger on a touchscreen) cannot be suppressed by cancelling a pointer event. Authors must instead use <code>touch-action</code> to explicitly <a href="#declaring-candidate-regions-for-direct-manipulation-behaviors">declare the direct manipulation behavior</a> for a region of the document. Removing this dependency on the cancellation of events facilitates performance optimizations by the user agent.</p>

                        <p>For all pointer events in the table above except <code>pointerenter</code> and <code>pointerleave</code> the {{EventInit/composed}} [[DOM]] attribute SHOULD be <code>true</code>.
                           For all pointer events in the table above the {{UIEvent/detail}} [[UIEVENTS]] attribute SHOULD be 0.</p>
                        <div class="note">Many user agents expose non-standard attributes <code>fromElement</code> and <code>toElement</code> in MouseEvents to support legacy content.  In those user agents, the values of those (inherited) attributes in PointerEvents must be <code>null</code> to encourage the use of the standardized alternates (i.e. <code>target</code> and <code>relatedTarget</code>).</div>
                        <p>Similar to <code>MouseEvent</code> {{MouseEventInit/relatedTarget}}, the <code>relatedTarget</code> should be initialized to the element whose bounds the pointer just left (in the case of a <code>pointerover</code> or <code>pointerenter</code> event) or the element whose bounds the pointer is entering (in the case of a <code>pointerout</code> or <code>pointerleave</code>). For other pointer events, this value will default to null. Note that when an element receives the pointer capture all the following events for that pointer are considered to be inside the boundary of the capturing element.</p>
                        <p>For <code>gotpointercapture</code> and <code>lostpointercapture</code> all the attributes except the ones defined in the table above should be the same as the Pointer Event that caused the user agent to run <a href="#process-pending-pointer-capture">Process Pending Pointer Capture</a> and fire the <code>gotpointercapture</code> and <code>lostpointercapture</code> events.</p>
                </section>

                <section>
                    <h3>Process pending pointer capture</h3>
                    <p>The user agent MUST run the following steps when <a href="#implicit-release-of-pointer-capture">implicitly releasing pointer capture</a> as well as when firing Pointer Events that are not <code>gotpointercapture</code> or <code>lostpointercapture</code>.</p>
                    <ol>
                        <li>If the <a>pointer capture target override</a> for this pointer is set and is not equal to the <a>pending pointer capture target override</a>, then fire a pointer event named <code>lostpointercapture</code> at the <a>pointer capture target override</a> node.
                        </li>
                        <li>If the <a>pending pointer capture target override</a> for this pointer is set and is not equal to the <a>pointer capture target override</a>, then fire a pointer event named <code>gotpointercapture</code> at the <a>pending pointer capture target override</a>.
                        </li>
                        <li>Set the <dfn>pointer capture target override</dfn> to the <a>pending pointer capture target override</a>, if set. Otherwise, clear the <a>pointer capture target override</a>.</li>
                    </ol>
                </section>
            </section>
        </section>

        <section>
            <h2>Pointer Event types</h2>
            <p>Below are the event types defined in this specification.</p>
            <p>In the case of the <a>primary pointer</a>, these events (with the exception of <code>gotpointercapture</code> and <code>lostpointercapture</code>) may also fire <a>compatibility mouse events</a>.</p>
            <section>
                <h3>The <dfn><code>pointerover</code> event</dfn></h3>
                <p>A user agent MUST <a>fire a pointer event</a> named <code>pointerover</code> when a pointing device is moved into the hit test boundaries of an element. Note that <code>setPointerCapture</code> or <code>releasePointerCapture</code> might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events. A user agent MUST also fire this event prior to firing a <code>pointerdown</code> event for <a href=#mapping-for-devices-that-do-not-support-hover>devices that do not support hover</a> (see <code><a href="#the-pointerdown-event">pointerdown</a></code>).</p>
            </section>
            <section>
                <h3>The <dfn><code>pointerenter</code> event</dfn></h3>
                <p>A user agent MUST <a>fire a pointer event</a> named <code>pointerenter</code> when a pointing device is moved into the hit test boundaries of an element or one of its descendants, including as a result of a <code>pointerdown</code> event from a device that <a href=#mapping-for-devices-that-do-not-support-hover>does not support hover</a> (see <code><a href="#the-pointerdown-event">pointerdown</a></code>). Note that <code>setPointerCapture</code> or <code>releasePointerCapture</code> might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events. This event type is similar to <code>pointerover</code>, but differs in that it does not bubble.</p>
                <div class="note">There are similarities between this event type, the <code>mouseenter</code> event described in [[UIEVENTS]], and the CSS <code>:hover</code> pseudo-class described in [[CSS21]]. See also the <a><code>pointerleave</code> event</a>.</div>
            </section>
            <section>
                <h3>The <dfn><code>pointerdown</code> event</dfn></h3>
                <p>A user agent MUST <a>fire a pointer event</a> named <code>pointerdown</code> when a pointer enters the <a>active buttons state</a>. For mouse, this is when the device transitions from no buttons depressed to at least one button depressed. For touch, this is when physical contact is made with the <a>digitizer</a>. For pen, this is when the pen either makes physical contact with the digitizer without any button depressed, or transitions from no buttons depressed to at least one button depressed while hovering.</p>
                <div class="note">For mouse (or other multi-button pointer devices), this means <code>pointerdown</code> and <code>pointerup</code> are not fired for all of the same circumstances as <code>mousedown</code> and <code>mouseup</code>. See <a href="#chorded-button-interactions">chorded buttons</a> for more information.</div>
                <p>For input <a href=#mapping-for-devices-that-do-not-support-hover>devices that do not support hover</a>, a user agent MUST also <a>fire a pointer event</a> named <code>pointerover</code> followed by a pointer event named <code>pointerenter</code> prior to dispatching the <code>pointerdown</code> event.</p>
                <div class="note">Authors can prevent the firing of certain <a data-lt="compatibility mapping with mouse events">compatibility mouse events</a> by canceling the <code>pointerdown</code> event (if the <code>isPrimary</code> property is <code>true</code>). This sets the <code>PREVENT MOUSE EVENT</code> flag on the pointer. Note, however, that this does not prevent the <code>mouseover</code>, <code>mouseenter</code>, <code>mouseout</code>, or <code>mouseleave</code> events from firing.</div>
            </section>
            <section>
                <h3>The <dfn><code>pointermove</code> event</dfn></h3>
                <p>A user agent MUST <a>fire a pointer event</a> named <code>pointermove</code> when a pointer changes button state.
                Additionally one <code>pointermove</code> MUST be fired when pointer changes coordinates, pressure, tangential pressure, tilt, twist, or
                contact geometry (e.g. <code>width</code> and <code>height</code>) and the circumstances produce no other pointer events defined in this specification. User agents MAY delay dispatch of the <code>pointermove</code> event (for instance, for performance reasons).
                The <a>coalesced events</a> information will be exposed via <code><a data-lt="PointerEvent.getCoalescedEvents">getCoalescedEvents</a></code> for the single dispatched <code>pointermove</code> event.
                The final coordinates of such events should be used for finding the target of the event.</p>
            </section>
            <section>
                <h3>The <dfn><code>pointerrawupdate</code> event</dfn></h3>
                <p>A user agent MUST <a>fire a pointer event</a>
                named <code>pointerrawupdate</code> only within a [=secure context=] when
                a pointer's attributes (i.e. button state, coordinates, pressure, tangential pressure, tilt, twist, or contact geometry) change.</p>
                <p>In contrast with <code>pointermove</code>, user agents SHOULD dispatch <code>pointerrawupdate</code> events as soon as possible
                and as frequently as the JavaScript can handle the events.</p>
                <p>The <code>target</code> of <code>pointerrawupdate</code> events might be different from the <code>pointermove</code> events
                due to the fact that <code>pointermove</code> events might get delayed or coalesced, and the final position of the event
                which is used for finding the <code>target</code> could be different from its coalesced events.</p>
                <p>Note that if there is already another <code>pointerrawupdate</code> with the same <code>pointerId</code> that hasn't been dispatched
                in the [=event loop=], the
                user agent MAY coalesce the new <code>pointerrawupdate</code> with that event instead of creating a new [=task=].
                This may cause <code>pointerrawupdate</code> to have coalesced events, and
                they will all be delivered as <a>coalesced events</a> of one <code>pointerrawupdate</code> event as soon as
                the event is processed in the [=event loop=].
                See <code><a data-lt="PointerEvent.getCoalescedEvents">getCoalescedEvents</a></code> for more information.</p>
                <p>In terms of ordering of <code>pointerrawupdate</code> and <code>pointermove</code>,
                if the user agent received an update from the platform that causes both <code>pointerrawupdate</code> and <code>pointermove</code> events,
                then the user agent MUST dispatch the <code>pointerrawupdate</code> event before the corresponding <code>pointermove</code>.</p>
                <p>Other than the <code>target</code>, the concatenation of coalesced events lists of all dispatched <code>pointerrawupdate</code> events
                since the last <code>pointermove</code> event is the same as the coalesced events of the next <code>pointermove</code> event in terms of the other event attributes.
                The attributes of <code>pointerrawupdate</code> are mostly the same as <code>pointermove</code>, with the exception of
                <code>cancelable</code> which MUST be false for <code>pointerrawupdate</code>.</p>
                <p>User agents SHOULD not fire <a>compatibility mouse events</a> for <code>pointerrawupdate</code>.</p>
                <div class="note">Adding listeners for the <code>pointerrawupdate</code> event might negatively impact the performance of the web page, depending on the implementation of the user agent.
                For most use cases the other pointerevent types should suffice.
                A <code>pointerrawupdate</code> listener should only be added if JavaScript needs high frequency events and can handle them just as fast.
                In these cases, there is probably no need to listen to other types of pointer events.</div>
            </section>
            <section>
                <h3>The <dfn><code>pointerup</code> event</dfn></h3>
                <p>A user agent MUST <a>fire a pointer event</a> named <code>pointerup</code> when a pointer leaves the <a>active buttons state</a>. For mouse, this is when the device transitions from at least one button depressed to no buttons depressed. For touch, this is when physical contact is removed from the <a>digitizer</a>. For pen, this is when the pen is removed from the physical contact with the digitizer while no button is depressed, or transitions from at least one button depressed to no buttons depressed while hovering.</p>
                <p>For input <a href=#mapping-for-devices-that-do-not-support-hover>devices that do not support hover</a>, a user agent MUST also <a>fire a pointer event</a> named <code>pointerout</code> followed by a pointer event named <code>pointerleave</code> after dispatching the <code>pointerup</code> event.</p>
                <div class="note">For mouse (or other multi-button pointer devices), this means <code>pointerdown</code> and <code>pointerup</code> are not fired for all of the same circumstances as <code>mousedown</code> and <code>mouseup</code>. See <a href="#chorded-button-interactions">chorded buttons</a> for more information.</div>
            </section>
            <section>
                <h3>The <dfn><code>pointercancel</code> event</dfn></h3>
                <p>A user agent MUST <a>fire a pointer event</a> named <code>pointercancel</code> in the following circumstances:</p>
                <ul>
                    <li>The user agent has determined that a pointer is unlikely to continue to produce events (for example, because of a hardware event).</li>
                    <li>After having fired the <code>pointerdown</code> event, if the pointer is subsequently used to manipulate the page viewport (e.g. panning or zooming).
                     <div class="note">User agents can trigger panning or zooming through multiple pointer types (such as touch and pen),
                     and therefore the start of a pan or zoom action may result in the cancellation of various pointers, including pointers with different pointer types.
                     To prevent cancellation of the pointer stream due to these behaviors see <a href="#the-touch-action-css-property">the touch-action CSS property section</a>.</div></li>
                    <li>Immediately before <a data-cite="html/#initiate-the-drag-and-drop-operation">drag operation starts</a> [[HTML]],
                     for the pointer that caused the drag operation.
                     <div class="note">If the start of the drag operation is prevented through any means
                     (e.g. through calling <code>preventDefault</code> on the <code>dragstart</code> event)
                     there will be no <code>pointercancel</code> event.</div></li>
                </ul>
                <p>After firing the <code>pointercancel</code> event, a user agent MUST also fire a pointer event named <code>pointerout</code> followed by firing a pointer event named <code>pointerleave</code>.</p>
                <div class="note">
                    <p><em>This section is non-normative.</em></p>
                    <p>Examples of scenarios in which a user agent might determine that a pointer is unlikely to continue to produce events include:
                    <ul>
                        <li>A device's screen orientation is changed while a pointer is active.</li>
                        <li>The user inputs a greater number of simultaneous pointers than is supported by the device.</li>
                        <li>The user agent interprets the input as accidental (for example, the hardware supports palm rejection).</li>
                        <li>The user agent interprets the input as a pan or zoom gesture.</li>
                    </ul>
                    <p>Methods for changing the device's screen orientation, recognizing accidental input, or using a pointer to manipulate the viewport (e.g. panning or zooming) are out of scope for this specification.</p>
                </div>
            </section>
            <section>
                <h3>The <dfn><code>pointerout</code> event</dfn></h3>
                <p>A user agent MUST <a>fire a pointer event</a> named <code>pointerout</code> when any of the following occurs:</p>
                <ul>
                    <li>A pointing device is moved out of the hit test boundaries of an element. Note that <code>setPointerCapture</code> or <code>releasePointerCapture</code> might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events.</li>
                    <li>After firing the <code>pointerup</code> event for a device that <a href=#mapping-for-devices-that-do-not-support-hover>does not support hover</a> (see <code><a href="#the-pointerup-event">pointerup</a></code>).</li>
                    <li>After firing the <code>pointercancel</code> event  (see <code><a href="#the-pointercancel-event">pointercancel</a></code>).</li>
                    <li>When a pen/stylus leaves the hover range detectable by the digitizer.</li>
                </ul>
            </section>
            <section>
                <h3>The <dfn><code>pointerleave</code> event</dfn></h3>
                <p>A user agent MUST <a>fire a pointer event</a> named <code>pointerleave</code> when a pointing device is moved out of the hit test boundaries of an element and all of its descendants, including as a result of a <code>pointerup</code> and <code>pointercancel</code> events from a device that <a href=#mapping-for-devices-that-do-not-support-hover>does not support hover</a> (see <code><a href="#the-pointerup-event">pointerup</a></code> and <code><a href="#the-pointercancel-event">pointercancel</a></code>). Note that <code>setPointerCapture</code> or <code>releasePointerCapture</code> might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events. User agents MUST also <a>fire a pointer event</a> named <code>pointerleave</code> when a pen/stylus leaves hover range detectable by the digitizer. This event type is similar to <code>pointerout</code>, but differs in that it does not bubble and that it MUST not be fired until the pointing device has left the boundaries of the element and the boundaries of all of its descendants.</p>
                <div class="note">There are similarities between this event type, the <code>mouseleave</code> event described in [[UIEVENTS]], and the CSS <code>:hover</code> pseudo-class described in [[CSS21]]. See also the <code>pointerenter</code> event.</div>
            </section>
            <section>
                <h3>The <dfn><code>gotpointercapture</code> event</dfn></h3>
                <p>A user agent MUST <a>fire a pointer event</a> named <code>gotpointercapture</code> when an element receives pointer capture. This event is fired at the element that is receiving pointer capture. Subsequent events for that pointer will be fired at this element. See the <a href="#setting-pointer-capture">Setting Pointer Capture</a> and <a href="#process-pending-pointer-capture">Process Pending Pointer Capture</a> sections.</p>
            </section>
            <section>
                <h3>The <dfn><code>lostpointercapture</code> event</dfn></h3>
                <p>A user agent MUST <a>fire a pointer event</a> named <code>lostpointercapture</code> after pointer capture is released for a pointer. This event MUST be fired prior to any subsequent events for the pointer after capture was released. This event is fired at the element from which pointer capture was removed. Subsequent events for the pointer follow normal hit testing mechanisms (out of scope for this specification) for determining the event target. See the <a href="#releasing-pointer-capture">Releasing Pointer Capture</a>, <a href="#implicit-release-of-pointer-capture">Implicit Release of Pointer Capture</a>, and <a href="#process-pending-pointer-capture">Process Pending Pointer Capture</a> sections.</p>
            </section>
            <section>
                <h3>The <dfn><code>click</code>, <code>auxclick</code>, and <code>contextmenu</code> events</dfn></h3>
                <p>This section is an addition to <a data-cite="uievents/#event-type-click">click</a> and
                   <a data-cite="uievents/#event-type-auxclick">auxclick</a> events defined in [[UIEVENTS]] and
                   [=HTMLElement/contextmenu=] defined in [[HTML]].
                   The type of these events MUST be <code>PointerEvent</code> but the dispatch process is going to match that of the original specification.
                   For these events, all <code>PointerEvent</code> specific attributes (defined in this spec) other than <code>pointerId</code> and <code>pointerType</code> will have their default values.
                   The <code>pointerId</code> and <code>pointerType</code> of these events MUST be the same as the PointerEvents that caused these events if they are generated by a pointing device.
                   If the events are generated by a non-pointing device (such as voice recognition software or a keyboard interaction), <code>pointerId</code> MUST be <code>-1</code> and <code>pointerType</code> MUST be an empty string.</p>
            </section>
        </section>
    </section>

    <section>
        <h2>Extensions to the `Element` interface</h2>
        <div>
            <p>The following section describes extensions to the existing {{Element}} interface to facilitate the setting and releasing of pointer capture.</p>
            <pre class="idl">
partial interface Element {
  undefined setPointerCapture (long pointerId);
  undefined releasePointerCapture (long pointerId);
  boolean hasPointerCapture (long pointerId);
};
            </pre>
            <dl data-dfn-for="Element" data-link-for="Element">
                <dt><dfn>setPointerCapture</dfn></dt>
                <dd>
                    <p><a href="#setting-pointer-capture">Sets</a> <a>pointer capture</a> for the pointer identified by the argument <code>pointerId</code> to the element on which this method is invoked. For subsequent events of the pointer, the capturing target will substitute the normal hit testing result as if the pointer is always over the capturing target, and they MUST always be targeted at this element until capture is released. The pointer MUST be in its <a>active buttons state</a> for this method to be effective, otherwise it fails silently. When the provided method's argument does not match any of the <a data-lt="active pointer">active pointers</a>, [=exception/throw=] a {{"NotFoundError"}} {{DOMException}}.</p>
                </dd>
                <dt><dfn>releasePointerCapture</dfn></dt>
                <dd>
                    <p><a href="#releasing-pointer-capture">Releases</a> <a>pointer capture</a> for the pointer identified by the argument <code>pointerId</code> from the element on which this method is invoked. Subsequent events for the pointer follow normal hit testing mechanisms (out of scope for this specification) for determining the event target. When the provided method's argument does not match any of the <a data-lt="active pointer">active pointers</a>, [=exception/throw=] a {{"NotFoundError"}} {{DOMException}}.</p>
                </dd>
                <dt><dfn>hasPointerCapture</dfn></dt>
                <dd>
                    <p>Indicates whether the element on which this method is invoked has <a>pointer capture</a> for the pointer identified by the argument <code>pointerId</code>.  In particular, returns <code>true</code> if the <a>pending pointer capture target override</a> for <code>pointerId</code> is set to the element on which this method is invoked, and <code>false</code> otherwise.</p>
                    <div class="note">This method will return true immediately after a call to <a>setPointerCapture</a>, even though that element will not yet have received a <a>gotpointercapture event</a>.  As a result it can be useful for detecting <a>implicit pointer capture</a> from inside of a <a>pointerdown event</a> listener.</div>
                </dd>
            </dl>
        </div>
    </section>
    <section>
        <h2>Extensions to the `GlobalEventHandlers` mixin</h2>
        <div>
            <p>The following section describes extensions to the existing {{GlobalEventHandlers}} mixin to facilitate the event handler registration.</p>
            <pre class="idl">
partial interface mixin GlobalEventHandlers {
    attribute EventHandler ongotpointercapture;
    attribute EventHandler onlostpointercapture;
    attribute EventHandler onpointerdown;
    attribute EventHandler onpointermove;
    [SecureContext] attribute EventHandler onpointerrawupdate;
    attribute EventHandler onpointerup;
    attribute EventHandler onpointercancel;
    attribute EventHandler onpointerover;
    attribute EventHandler onpointerout;
    attribute EventHandler onpointerenter;
    attribute EventHandler onpointerleave;
};
            </pre>
            <dl data-dfn-for="GlobalEventHandlers" data-link-for="GlobalEventHandlers">
                <dt><dfn>ongotpointercapture</dfn></dt>
                <dd>
                    The [=event handler IDL attribute=] for the <code>gotpointercapture</code> event type.
                </dd>
                <dt><dfn>onlostpointercapture</dfn></dt>
                <dd>
                    The [=event handler IDL attribute=] for the <code>lostpointercapture</code> event type.
                </dd>
                <dt><dfn>onpointerdown</dfn></dt>
                <dd>
                    The [=event handler IDL attribute=] for the <code>pointerdown</code> event type.
                </dd>
                <dt><dfn>onpointermove</dfn></dt>
                <dd>
                    The [=event handler IDL attribute=] for the <code>pointermove</code> event type.
                </dd>
                <dt><dfn>onpointerup</dfn></dt>
                <dd>
                    The [=event handler IDL attribute=] for the <code>pointerup</code> event type.
                </dd>
                <dt><dfn>onpointercancel</dfn></dt>
                <dd>
                    The [=event handler IDL attribute=] for the <code>pointercancel</code> event type.
                </dd>
                <dt><dfn>onpointerover</dfn></dt>
                <dd>
                    The [=event handler IDL attribute=] for the <code>pointerover</code> event type.
                </dd>
                <dt><dfn>onpointerout</dfn></dt>
                <dd>
                    The [=event handler IDL attribute=] for the <code>pointerout</code> event type.
                </dd>
                <dt><dfn>onpointerenter</dfn></dt>
                <dd>
                    The [=event handler IDL attribute=] for the <code>pointerenter</code> event type.
                </dd>
                <dt><dfn>onpointerleave</dfn></dt>
                <dd>
                    The [=event handler IDL attribute=] for the <code>pointerleave</code> event type.
                </dd>
            </dl>
        </div>
    </section>

    <section>
        <h2>Extensions to the `Navigator` interface</h2>
        <div>
            <p>The {{Navigator}} interface is defined in [[HTML]]. This specification extends the <code>Navigator</code> interface to provide device detection support.</p>
            <pre class="idl">
partial interface Navigator {
    readonly  attribute long maxTouchPoints;
};
            </pre>
            <dl data-dfn-for="Navigator" data-link-for="Navigator">
                <dt><dfn>maxTouchPoints</dfn></dt>
                <dd><p>The maximum number of simultaneous touch contacts supported by the device. In the case of devices with multiple digitizers (e.g. multiple touchscreens), the value MUST be the maximum of the set of maximum supported contacts by each individual digitizer.</p>
                <p>For example, suppose a device has 3 touchscreens, which support 2, 5, and 10 simultaneous touch contacts, respectively. The value of <code>maxTouchPoints</code> should be <code>10</code>.</p>
                </dd>
            </dl>
            <div class="note">While a <code>maxTouchPoints</code> value of greater than 0 indicates the user's device is capable of supporting touch input, it does not necessarily mean the user <em>will</em> use touch input. Authors should be careful to also consider other input modalities that could be present on the system, such as mouse, pen, screen readers, etc.</div>
            <div class="note"><code>maxTouchPoints</code> is often used to ensure that the interaction model of the content can be recognized by the current hardware. UI affordances can be provided to users with less capable hardware. On platforms where the precise number of touch points is not known, the minimum number guaranteed to be recognized is provided. Therefore, it is possible for the number of recognized touch points to exceed the value of <code>maxTouchPoints</code>.</div>
        </div>
    </section>
    <section>
        <h1>Declaring candidate regions for direct manipulation behaviors</h1>
        <p>As noted in <a href="#attributes-and-default-actions">Attributes and Default Actions</a>, viewport manipulations (panning and zooming) cannot be suppressed by cancelling a pointer event. Instead, authors must explicitly define which of these behaviors they want to allow, and which they want to suppress, using the <code>touch-action</code> CSS property.</p>
        <div class="note">While the issue of pointers used to manipulate the viewport is generally limited to touch input (where a user's finger can both interact with content and panning/zoom the page), certain user agents may also allow the same types of (direct or indirect) manipulation for other pointer types. For instance, on mobile/tablet devices, users may also be able to scroll using a stylus. While, for historical reasons, the <code>touch-action</code> CSS property defined in this specification appears to refer only to touch inputs, it does in fact apply to all forms of pointer inputs that allow <a>direct manipulation</a> for panning and zooming.</div>
        <section>
            <h2>The <code>touch-action</code> CSS property</h2>
            <table class="simple">
                <tr><th>Name:</th><td><code><dfn>touch-action</dfn></code></td></tr>
                <tr><th>Value:</th><td><code>auto</code> | <code>none</code> | [ [ <code>pan-x</code> | <code>pan-left</code> | <code>pan-right</code> ] || [ <code>pan-y</code> | <code>pan-up</code> | <code>pan-down</code> ] ] | <code>manipulation</code></td></tr>
                <tr><th>Initial:</th><td><code>auto</code></td></tr>
                <tr><th>Applies to:</th><td>all elements except: non-replaced inline elements, table rows, row groups, table columns, and column groups.</td></tr>
                <tr><th>Inherited:</th><td>no</td></tr>
                <tr><th>Percentages:</th><td>N/A</td></tr>
                <tr><th>Media:</th><td>visual</td></tr>
                <tr><th>Computed value:</th><td>Same as specified value.</td></tr>
            </table>

            <p>The <code>touch-action</code> CSS property determines whether <a>direct manipulation</a> interactions (which are not limited to touch, despite the property's name) MAY trigger the user agent's panning and zooming behavior. See the section on <a href="#details-of-touch-action-values"><code>touch-action</code> values</a>.</p>

            <p>While panning and zooming, the user agent MUST NOT fire subsequent pointer events for the pointer. In order to end the stream of events for the pointer, the user agent MUST <a>fire a pointer event</a> named <code>pointercancel</code> (and subsequently a <code>pointerout</code> event and one or more <code>pointerleave</code> events) whenever all of the following are true:</p>
            <ul>
                <li>The user agent has determined (via methods out of scope for this specification) that a direct manipulation interaction is to be consumed for panning or zooming,</li>
                <li>a <code>pointerdown</code> event has been sent for the pointer, and</li>
                <li>a <code>pointerup</code> or <code>pointercancel</code> event (following the above mentioned <code>pointerdown</code>) has not yet been sent for the pointer.</li>
            </ul>

            <div class="note">User agents may implement complex gestures for behaviors that involve a series of separate discrete gestures, but which are all treated as part of a single continuous gesture. For example, consider a "fling to scroll" gesture on a touchscreen: a user starts panning the document with a rapid finger movement, lifts the finger from the touchscreen, and the document continues panning with simulated inertia. While the document is still moving, the user may place their finger on the touchscreen and execute another "fling" to provide further momentum for the panning, or counteract the current panning to slow it down, stop panning altogether, or reverse the direction of the panning. As this specification does not normatively define how gestures and behaviors are implemented, it is left up to the user agent to decide whether or not the second touch (before it is interpreted as a second "fling" or counteraction of the current panning) should fire pointer events or not.</div>

            <div class="note"><code>touch-action</code> does not apply/cascade through to embedded browsing contexts. For instance, even applying <code>touch-action</code> to an <code>&lt;iframe&gt;</code> won't have any effect on the behavior of direct manipulation interactions for panning and zooming within the <code>&lt;iframe&gt;</code> itself.</div>
        </section>

        <section>
          <h2>Determining supported direct manipulation behavior</h2>
          <p>When a user interacts with an element using a <a>direct manipulation</a> pointer (such as touch or stylus on a touchscreen), the effect of that input is determined by the value of the <code>touch-action</code> property, and the default direct manipulation behaviors of the element and its ancestors, as follows:</p>
          <ul>
            <li>A direct manipulation interaction for panning and zooming <dfn data-lt="conforming-touch-behavior">conforms to an element's <code>touch-action</code></dfn> if the behavior is allowed in the coordinate space of the element. Note that if CSS transforms have been applied, the element's coordinate space may differ from the screen coordinate in a way to affect the conformity here; for example, the X axis of an element rotated by 90 degrees with respect to the screen will be parallel to the Y-axis of the screen coordinate.</li>
            <li>A direct manipulation interaction for panning and zooming is supported if it <a data-lt="conforming-touch-behavior">conforms</a> to the <code>touch-action</code> property of each element between the hit tested element and its nearest ancestor with the default direct manipulation behavior (including both the hit tested element and the element with the default direct manipulation behavior).</li>
            <li>Once panning or zooming has been started, and the user agent has already determined whether or not the gesture should be handled as a user agent direct manipulation behavior, any changes to the relevant <code>touch-action</code> value will be ignored for the duration of the action. For instance, programmatically changing the <code>touch-action</code> value for an element from <code>auto</code> to <code>none</code> as part of a <code>pointerdown</code> handler script will not result in the user agent aborting or suppressing any of the pan or zoom behavior for that input for as long as that pointer is active.</li>
            <li>Similarly, in the case of the various <code>touch-action</code> values of <code>pan-*</code>, once the user agent has determined whether to handle a gesture directly or not at the start of the gesture, a subsequent change in the direction of the same gesture SHOULD be ignored by the user agent for as long as that pointer is active. For instance, if an element has been set to <code>touch-action: pan-y</code> (meaning that only vertical panning is handled by the user agent), and a touch gesture starts off horizontally, no vertical panning should occur if the user changes the direction of their gesture to be vertical while their finger is still touching the screen.</li>
          </ul>

          <div class="note">Some user agents support panning and zooming interactions involving multiple concurrent pointers (e.g. multi-touch). Methods for processing or associating the <code>touch-action</code> values of multiple concurrent pointers is out of scope for this specification.</div>
        </section>

        <section>
          <h2>Details of <code>touch-action</code> values</h2>
          <p>The <code>touch-action</code> property covers direct manipulation behaviors related to viewport panning and zooming. Any additional user agent behaviors, such as text selection/highlighting, or activating links and form controls, MUST NOT be affected by this CSS property.</p>
          <div class="note">The terms "panning" and "scrolling" are considered synonymous (or, more aptly, "panning" is "scrolling" using a direct manipulation input). Defining an interaction or gesture for triggering panning/scrolling, or for triggering behavior for the <code>auto</code> or <code>none</code> values, are out of scope for this specification.</div>
          <dl>
            <dt>auto</dt>
            <dd>The user agent MAY consider any permitted direct manipulation behaviors related to panning and zooming of the viewport that begin on the element.</dd>
            <dt>none</dt>
            <dd>Direct manipulation interactions that begin on the element MUST NOT trigger behaviors related to viewport panning and zooming.</dd>
            <dt>pan-x<br>pan-left<br>pan-right<br>pan-y<br>pan-up<br>pan-down</dt>
            <dd>The user agent MAY consider direct manipulation interactions that begin on the element only for the purposes of panning that starts in any of the directions specified by all of the listed values.  Once panning has started, the direction may be reversed by the user even if panning that starts in the reversed direction are disallowed. In contrast, when panning is restricted to a single axis (eg. <code>pan-y</code>), the axis cannot be changed during panning.<p>
            <dt>manipulation</dt>
            <dd>The user agent MAY consider direct manipulation interactions that begin on the element only for the purposes of panning and <strong>continuous</strong> zooming (such as pinch-zoom), but MUST NOT trigger other related behaviors that rely on multiple activations that must happen within a set period of time (such as double-tap to zoom, or double-tap and hold for single-finger zoom).</dd>
          </dl>
          <div class="note"><a data-cite="compat/#touch-action">Additional <code>touch-action</code> values</a> common in implementations are defined in [[COMPAT]].</div>
          <div class="note">The <code>touch-action</code> property only applies to elements that support both the CSS <code>width</code> and <code>height</code> properties (see [[CSS21]]). This restriction is designed to facilitate user agent optimizations for <em>low-latency</em> <a>direct manipulation</a> panning and zooming. For elements not supported by default, such as <code>&lt;span&gt;</code> which is a <em>non-replaced inline element</em>, authors can set the <code>display</code> CSS property to a value, such as <code>block</code>, that supports <code>width</code> and <code>height</code>. Future specifications could extend this API to all elements.</div>
          <div class="note">
            <p>The direction-specific pan values are useful for customizing some overscroll behaviors.
               For example, to implement a simple pull-to-refresh effect the document's <code>touch-action</code> can be set to <code>pan-x pan-down</code> whenever the scroll position is 0 and <code>pan-x pan-y</code> otherwise.
               This allows pointer event handlers to define the behavior for upward panning/scrolling that start from the top of the document.</p>
            <p>The direction-specific pan values can also be used for composing a component that implements custom panning with pointer event handling within an element that scrolls natively (or vice-versa).
               For example, an image carousel may use <code>pan-y</code> to ensure it receives pointer events for any horizontal pan operations without interfering with vertical panning of the document.
               When the carousel reaches its right-most extent, it may change its <code>touch-action</code> to <code>pan-y pan-right</code> so that a subsequent scroll operation beyond its extent can scroll the document within the viewport if possible.
               It's not possible to change the behavior of a panning/scrolling operation while it is taking place.</p>
          </div>
          <div class="note">Disabling some default direct manipulation behaviors for panning and zooming may allow user agents to respond to other behaviors more quickly.  For example, with <code>auto</code> user agents typically add 300ms of delay before <code>click</code> to allow for double-tap gestures to be handled.  In these cases, explicitly setting <code>touch-action: none</code> or <code>touch-action: manipulation</code> will remove this delay. Note that the methods for determining a tap or double-tap gesture are out of scope for this specification.</div>
        </section>
<pre id="example_5" class="example" title="Disallowing all direct manipulation behaviors">
<code>&lt;div style=&quot;touch-action: none;&quot;&gt;
    This element receives pointer events for all direct manipulation interactions that otherwise lead to panning or zooming.
&lt;/div&gt;</code>
</pre>
<pre id="example_6" class="example" title="Allowing horizontal panning only">
<code>&lt;div style=&quot;touch-action: pan-x;&quot;&gt;
    This element receives pointer events when not panning in the horizontal direction.
&lt;/div&gt;</code>
</pre>
<pre id="example_7" class="example" title="Child regions that disallow direct manipulation behaviors for panning and zooming">
<code>&lt;div style=&quot;overflow: auto;&quot;&gt;
    &lt;div style=&quot;touch-action: none;&quot;&gt;
        This element receives pointer events for all direct manipulation interactions that otherwise lead to panning or zooming.
    &lt;/div&gt;
    &lt;div&gt;
        Direct manipulation interactions on this element MAY be consumed for manipulating the parent.
    &lt;/div&gt;
&lt;/div&gt;</code>
</pre>
<pre id="example_8" class="example" title="Intermediate parent that disallows direct manipulation behaviors for panning and zooming">
<code>&lt;div style=&quot;overflow: auto;&quot;&gt;
    &lt;div style=&quot;touch-action: pan-y;&quot;&gt;
        &lt;div style=&quot;touch-action: pan-x;&quot;&gt;
            This element receives pointer events for all direct manipulation interactions because
            it allows only horizontal panning yet an intermediate ancestor
            (between it and the scrollable element) only allows vertical panning.
            Therefore, no direct manipulation behaviors for panning/zooming are
            handled by the user agent.
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</code>
</pre>
<pre id="example_9" class="example" title="Intermediate parent that restricts allowed direct manipulation behaviors for panning and zooming">
&lt;div style=&quot;overflow: auto;&quot;&gt;
    &lt;div style=&quot;touch-action: pan-y pan-left;&quot;&gt;
        &lt;div style=&quot;touch-action: pan-x;&quot;&gt;
            This element receives pointer events when not panning to the left.
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>
    </section>
    <section>
        <h1><dfn>Pointer capture</dfn></h1>
        <section class='informative'>
          <h2>Introduction</h2>
        <p>Pointer capture allows the events for a particular pointer (including any <a data-lt="compatibility mapping with mouse events">compatibility mouse events</a>) to be retargeted to a particular element other than the normal hit test result of the pointer's location. This is useful in scenarios like a custom slider control (e.g. similar to the [[HTML]] <code>&lt;input type="range"&gt;</code> control). Pointer capture can be set on the slider thumb element, allowing the user to slide the control back and forth even if the pointer slides off of the thumb.</p>
        <figure id="figure_slider">
            <img src="images/slider.png" alt="Custom Volume Slider">
            <figcaption>Example of a custom slider control that chooses a value by sliding the thumb element back and forth. After <code>pointerdown</code> on the thumb, pointer capture can be used to allow the user to slide the thumb even if the pointer drifts off of it.</figcaption>
        </figure>
        </section>
        <section>
            <h2>Setting pointer capture</h2>
            <p>Pointer capture is set on an |element| of type {{Element}} by calling the <code>element.setPointerCapture(pointerId)</code> method.
               When this method is invoked, a user agent MUST run the following steps:</p>
            <ol>
                <li>If the <code>pointerId</code> provided as the method's argument does not match any of the <a data-lt="active pointer">active pointers</a>, then [=exception/throw=] a {{"NotFoundError"}} {{DOMException}}.</li>
                <li>Let the |pointer| be the <a>active pointer</a> specified by the given <code>pointerId</code>.
                <li>If the |element| is not [=connected=] [[DOM]], [=exception/throw=] an {{"InvalidStateError"}} {{DOMException}}.</li>
                <li>If this method is invoked while the |element|'s [=Node/node document=] [[DOM]] has a locked element ([[PointerLock]] {{DocumentOrShadowRoot/pointerLockElement}}),
                    [=exception/throw=] an {{"InvalidStateError"}} {{DOMException}}.</li>
                <li>If the |pointer| is not in the <a>active buttons state</a> or
                    the |element|'s [=Node/node document=] is not the <a>active document</a> of the |pointer|, then terminate these steps.</li>
                <li>For the specified <code>pointerId</code>, set the <dfn>pending pointer capture target override</dfn> to the {{Element}} on which this method was invoked.</li>
            </ol>
        </section>

        <section>
            <h2>Releasing pointer capture</h2>
            <p>Pointer capture is released on an element explicitly by calling the <code>element.releasePointerCapture(pointerId)</code> method. When this method is called, a user agent MUST run the following steps:</p>
            <ol>
                <li>If the <code>pointerId</code> provided as the method's argument does not match any of the <a data-lt="active pointer">active pointers</a> and these steps are not being invoked as a result of the <a href="#implicit-release-of-pointer-capture">implicit release of pointer capture</a>, then [=exception/throw=] a {{"NotFoundError"}} {{DOMException}}.</li>
                <li>If <a href="#dom-element-haspointercapture">hasPointerCapture</a> is false for the {{Element}} with the specified <code>pointerId</code>, then terminate these steps.</li>
                <li>For the specified <code>pointerId</code>, clear the <a>pending pointer capture target override</a>, if set.</li>
            </ol>
        </section>
        <section>
            <h2><dfn>Implicit pointer capture</dfn></h2>
            <p>Inputs that implement <a>direct manipulation</a> interactions for panning and zooming (such as touch or stylus on a touchscreen) SHOULD behave exactly as if <a data-lt="Element.setPointerCapture">setPointerCapture</a> was called on the target element just before the invocation of any <code>pointerdown</code> listeners.  The <a data-lt="Element.hasPointerCapture">hasPointerCapture</a> API may be used (eg. within any <code>pointerdown</code> listener) to determine whether this has occurred.  If <a data-lt="Element.releasePointerCapture">releasePointerCapture</a> is not called for the pointer before the next pointer event is fired, then a <a>gotpointercapture event</a> will be dispatched to the target (as normal) indicating that capture is active.</p>
            <div class="note">This is a breaking change from [[PointerEvents]], but does not impact the vast majority of existing content. In addition to matching typical platform UX conventions, this design for implicit capture enables user agents to make a performance optimization which prevents the need to invoke hit-testing on touch movement events without explicit developer opt-in (consistent with the performance properties of existing dominant native and web APIs for touch input).</div>
            <div class="note">In addition, user agents may implement implicit pointer capture behavior for all input devices on specific UI widgets such as input range controls (allowing some finger movement to stray outside of the form control itself during the interaction).</div>
        </section>
        <section>
            <h3>Implicit release of pointer capture</h3>
            <p>Immediately after firing the <code>pointerup</code> or <code>pointercancel</code> events,
               a user agent MUST clear the <a>pending pointer capture target override</a>
               for the <code>pointerId</code> of the <code>pointerup</code> or <code>pointercancel</code> event that was just dispatched,
               and then run <a href="#process-pending-pointer-capture">Process Pending Pointer Capture</a> steps to fire <code>lostpointercapture</code> if necessary.
               After running <a href="#process-pending-pointer-capture">Process Pending Pointer Capture</a> steps,
               if the pointer supports hover, user agent MUST also send corresponding boundary events necessary
               to reflect the current position of the pointer with no capture. </p>
            <p>If the user agent supports firing the <code>click</code> event
               (see <a title="compatibility mouse events" href="#dfn-compatibility-mouse-events">compatibility mouse events</a>),
               and if in an implicit release scenario both <code>click</code> and <code>lostpointercapture</code> events are fired,
               <code>click</code> SHOULD be fired before <code>lostpointercapture</code>.</p>
            <p>When the <a>pointer capture target override</a> is no longer [=connected=] [[DOM]],
               the <a>pending pointer capture target override</a> and <a>pointer capture target override</a> nodes SHOULD be cleared
               and also a PointerEvent named <code>lostpointercapture</code> corresponding to the captured pointer SHOULD be fired at the document.</p>
            <p>When a pointer lock [[PointerLock]] is successfully applied on an element, a user agent MUST run the steps as if the <a data-lt='Element.releasePointerCapture'>releasePointerCapture()</a> method has been called if any element is set to be captured or pending to be captured.

        </section>
    </section>
    <section>
        <h1><dfn>Coalesced and predicted events</dfn></h1>

        <div class="note">This specification does not define how user agents should coalesce or
        predict pointer movement data. It only specifies the API for accessing this information.</div>

        <section>
            <h2><dfn>Coalesced events</dfn></h2>

            <p>For performance reasons, user agents may choose not to send a <code>pointermove</code>
            event every time a <a data-lt="measurable properties">measurable property</a>
            (such as coordinates, pressure, tangential pressure, tilt, twist, or contact geometry)
            of a pointer is updated. Instead, they may coalesce (combine/merge) multiple changes into
            a single <code>pointermove</code> or <code>pointerrawupdate</code> event. While
            this approach helps in reducing the amount of event handling the user agent must perform,
            it will naturally reduce the granularity and fidelity when tracking a pointer position,
            particularly for fast and large movements. Using the
            <code><a data-lt="PointerEvent.getCoalescedEvents">getCoalescedEvents</a></code> method
            it is possible for applications to access the raw, un-coalesced position changes. These
            allow for a more precise handling of pointer movement data. In the case of drawing
            applications, for instance, the un-coalesced events can be used to draw smoother curves that
            more closely match the actual movement of a pointer.</p>

            <figure id="figure_coalesced">
                <img src="images/coalesced-points.png" alt="Close-up view of a curve, showing coalesced and un-coalesced points">
                <figcaption>Example of a curve in a drawing application – using only the coalesced
                coordinates from <code>pointermove</code> events (the grey dots), the curve is noticeably
                angular and jagged; the same line drawn using the more granular points provided by
                <code>getCoalescedEvents</code> (the red circles) results in a smoother approximation
                of the pointer movement.</figcaption>
            </figure>

            <p>A <a>PointerEvent</a> has an associated <dfn>coalesced event list</dfn> (a list of
            zero or more <code>PointerEvent</code>s). If a trusted event is a <code>pointermove</code> or
            <code>pointerrawupdate</code> event, the list is a sequence of all <code>PointerEvent</code>s
            that were coalesced into this event; otherwise it is an empty list.
            Untrusted events have their <a>coalesced event list</a> initialized to the value passed to the
            constructor.</p>

            <p>The events in the coalesced event list of a trusted event will have increasing
            {{Event/timeStamp}}s, so the first event will have the smallest {{Event/timeStamp}}.</p>

            <pre id="example_10" class="example" title="Basic canvas drawing application using the coalesced events list">
                <code>&lt;style&gt;
                    /* Disable intrinsic user agent direct manipulation behaviors (such as panning or zooming)
                    so that all events on the canvas element are given to the application instead. */

                    canvas { touch-action: none; }
                &lt;/style&gt;

                &lt;canvas id="drawSurface" width="500px" height="500px" style="border:1px solid black;"&gt;&lt;/canvas&gt;

                &lt;script&gt;
                    const canvas = document.getElementById("drawSurface"),
                    context = canvas.getContext("2d");

                    canvas.addEventListener("pointermove", (e)=> {

                        if (e.getCoalescedEvents) {
                            for (let coalesced_event of e.getCoalescedEvents()) {
                                paint(coalesced_event); // Paint all raw/non-coalesced points
                            }
                        } else {
                            paint(e); // Paint the final coalesced point
                        }
                    });

                    function paint(event) {
                        if(event.buttons>0) {
                            context.fillRect(event.clientX, event.clientY, 5, 5);
                        }
                    }

                &lt;/script&gt;</code>
            </pre>

            <div class="note">The PointerEvent's attributes will be initalized in a way that best represents
            the events in the coalesced events list. For example its {{MouseEvent/movementX}} and {{MouseEvent/movementY}}
            ([[PointerLock]]) COULD be the sum of those of all the coalesced events.</div>

            <div class="note">
                <p>The order of all these dispatched events should resemble the actual order of the
                original events' order. For example if a <code>pointerdown</code> event causes the dispatch for the
                coalesced <code>pointermove</code> events the user agent SHOULD first dispatch one <code>pointermove</code>
                event with all those coalesced events of a <code>pointerId</code> followed by the <code>pointerdown</code> event.
                Here is an example of the actual events happening with increasing <code>timestamps</code> and the
                events dispatched by the user agent:</p>
                <table class="simple">
                    <thead><tr><th>Actual events</th><th>Dispatched events</th> </tr></thead>
                    <tbody>
                        <tr><td>pointer (<code>pointerId</code>=2) coordinate change</td><td><code>pointerrawupdate</code> (<code>pointerId</code>=2) w/ one coalesced event</code></td></tr>
                        <tr><td>pointer (<code>pointerId</code>=1) coordinate change</td><td><code>pointerrawupdate</code> (<code>pointerId</code>=1) w/ one coalesced event</code></td></tr>
                        <tr><td>pointer (<code>pointerId</code>=2) coordinate change</td><td><code>pointerrawupdate</code> (<code>pointerId</code>=2) w/ one coalesced event</code></td></tr>
                        <tr><td>pointer (<code>pointerId</code>=2) coordinate change</td><td><code>pointerrawupdate</code> (<code>pointerId</code>=2) w/ one coalesced event</code></td></tr>
                        <tr><td>pointer (<code>pointerId</code>=1) coordinate change</td><td><code>pointerrawupdate</code> (<code>pointerId</code>=1) w/ one coalesced event</code></td></tr>
                        <tr><td>pointer (<code>pointerId</code>=2) coordinate change</td><td><code>pointerrawupdate</code> (<code>pointerId</code>=2) w/ one coalesced event</code></td></tr>
                        <tr><td>pointer (<code>pointerId</code>=1) button press</td><td>
                        <code>pointermove</code> (<code>pointerId</code>=1) w/ two coalesced events<br>
                        <code>pointermove</code> (<code>pointerId</code>=2) w/ four coalesced events<br>
                        <code>pointerdown</code> (<code>pointerId</code>=1) w/ zero coalesced events<br>
                        </td></tr>
                        <tr><td>pointer (<code>pointerId</code>=2) coordinate change</td><td><code>pointerrawupdate</code> (<code>pointerId</code>=2) w/ one coalesced event</code></td></tr>
                        <tr><td>pointer (<code>pointerId</code>=2) coordinate change</td><td><code>pointerrawupdate</code> (<code>pointerId</code>=2) w/ one coalesced event</code></td></tr>
                        <tr><td>pointer (<code>pointerId</code>=1) button release</td><td>
                        <code>pointermove</code> (<code>pointerId</code>=2) w/ two coalesced events<br>
                        <code>pointerup</code> (<code>pointerId</code>=1) w/ zero coalesced events<br>
                        </td></tr>
                    </tbody>
                </table>
            </div>

        </section>

        <section>
            <h2><dfn>Predicted events</dfn></h2>
            
            <p>Some user agents have built-in algorithms which, after a series of confirmed pointer movements,
            can make a prediction (based on past points, and the speed/trajectory of the movement) what
            the position of future pointer movements may be. Applications can use this information with
            the <code><a data-lt="PointerEvent.getPredictedEvents">getPredictedEvents</a></code> method to speculatively "draw ahead" to a predicted position
            to reduce perceived latency, and then discarding these predicted points once the actual points
            are received.</p>

            <figure id="figure_predicted">
                <img src="images/predicted-points.png" alt="A line drawn using coalesced points, showing predicted future points">
                <figcaption>Example of a line in a drawing application (the result of a drawing gesture from the bottom left to the top right), using the coalesced coordinates from <code>pointermove</code> events, showing the user agent's predicted future points (the grey circles).</figcaption>
            </figure>

            <p>A <a>PointerEvent</a> has an associated <dfn>predicted event list</dfn> (a list of zero or more
            <code>PointerEvent</code>s). If a trusted event is a <code>pointermove</code> event, it is a sequence of
            <code>PointerEvent</code>s that the user agent predicts will follow the events in the
            <a>coalesced event list</a> in the future; otherwise it is an empty list.
            Untrusted events have their <a>predicted event list</a> initialized to the value passed to the
            constructor.</p>
            <div class="note">
                <p>While <code>pointerrawmove</code> events may have a non-empty <a>coalesced event list</a>,
                their <a>predicted event list</a> will, for performance reasons, usually be an empty list.</p>
            </div>
            <p>The number of events in the list and how far they are from the current timestamp are determined by
            the user agent and the prediction algorithm it uses.</p>

            <p>The events in the predicted event list of a trusted event will have monotonically increasing {{Event/timeStamp}}s [[DOM]],
            so the first event will have the smallest <code>timeStamp</code>. All predicted events have a <code>timeStamp</code>
            that is greater than the <code>timeStamp</code> of the dispatched pointer event that the
            <code><a data-lt="PointerEvent.getPredictedEvents">getPredictedEvents</a></code> method was called on.</p>

            <div class="note">
                <p>Note that authors should only consider predicted events as valid predictions until the next pointer event is
                dispatched. It is possible, depending on how far into the future the user agent predicts events, that regular
                pointer events are dispatched earlier than the timestamp of one or more of the predicted events.</p>
            </div>

            <pre id="example_11" class="example" title="Conceptual approach to drawing using coalesced events and predicted events">
                <code>
                let predicted_points = [];
                window.addEventListener("pointermove", function(event) {
                    // Clear the previously drawn predicted points.
                    for (let e of predicted_points.reverse()) {
                        clearPoint(e.pageX, e.pageY);
                    }

                    // Draw the actual movements that happened since the last received event.
                    for (let e of event.getCoalescedEvents()) {
                        drawPoint(e.pageX, e.pageY);
                    }
                
                    // Draw the current predicted points to reduce the perception of latency.
                    predicted_points = event.getPredictedEvents();
                    for (let e of predicted_points) {
                        drawPoint(e.pageX, e.pageY);
                    }
                });
                </code>
            </pre>
        </section>

        <section>
            <h2><dfn>Populating and maintaining the coalesced and predicted event lists</dfn></h2>
            <p>When a <a>PointerEvent</a> is created, run the following steps for each event in the
            <a>coalesced event list</a> and <a>predicted event list</a>:</p>
            <ol>
                <li>Set the event's <code>pointerId</code>, <code> pointerType</code>,
                <code>isPrimary</code> and <code>isTrusted</code> to the {{PointerEvent}}'s
                <code>pointerId</code>, <code>pointerType</code>, <code>isPrimary</code> and
                <code>isTrusted</code>.</li>
                <li>Set the event's <code>cancelable</code> and <code>bubbles</code> attributes to false.</li>
                <li>Set the event's <a>coalesced event list</a> and <a>predicted event list</a> to an empty list.</li>
                <li>Initialize the rest of the attributes the same way as <a>PointerEvent</a>.</li>
            </ol>

            <p>When a trusted <a>PointerEvent</a>'s target is changed:</p>
            <ol>
                <li>for each event in the <a>coalesced event list</a>, set the event's {{Event/target}}
                to this <code>PointerEvent</code>'s target.</li>
                <li>for each event in the <a>predicted event list</a>, set the event's {{Event/target}} to
                this <code>PointerEvent</code>'s <code>target</code>.</li>
            </ol>

        </section>

    </section>
    <section>
        <h1><dfn data-lt="compatibility mouse events">Compatibility mapping with mouse events</dfn></h1>
        <p>The vast majority of web content existing today codes only to Mouse Events. The following describes an algorithm for how a user agent MAY map generic pointer input to mouse events for compatibility with this content.</p>
        <p>The compatibility mapping with mouse events are an OPTIONAL feature of this specification. User agents are encouraged to support the feature for best compatibility with existing legacy content. User agents that do not support compatibility mouse events are still encouraged to support the <code>click</code> and <code>contextmenu</code> events (see the note below).</p>
        <div class="note">
            <p>The <code>click</code> event, defined in [[UIEVENTS]], and the <code>contextmenu</code> event are not considered <a title="compatibility mouse events" href="#dfn-compatibility-mouse-events">compatibility mouse events</a> as they are typically tied to user interface activation and are fired from other input devices, like keyboards.</p>
            <p>In user agents that support firing <code>click</code> and/or <code>contextmenu</code>, calling <code>preventDefault</code> during a pointer event typically does not have an effect on whether <code>click</code> and/or <code>contextmenu</code> are fired or not.  Because they are not compatibility mouse events, user agents typically fire <code>click</code> and <code>contextmenu</code> for all pointing devices, including pointers that are not primary pointers.</p>
            <p>The relative ordering of these high-level events (<code>click</code>, <code>contextmenu</code>, <code>focus</code>, <code>blur</code>, etc.) with pointer events is undefined and varies between user agents. For example, in some user agents <code>contextmenu</code> will often follow a <code>pointerup</code>, in others it'll often precede a <code>pointerup</code> or <code>pointercancel</code>, and in some situations it may be fired without any corresponding pointer event (such as a keyboard shortcut).</p>
            <p>In addition, user agents may apply their own heuristics to determine whether or not a <code>click</code> or <code>contextmenu</code> event should be fired. Some user agents may only fire these events for a primary pointer, and even then they may choose not to fire these events if there are other (non-primary) pointers of the same type, or other primary pointers of a different type. User agents may determine that a particular action was not a "clean" tap, click or long-press - for instance, if an interaction with a finger on a touch screen includes too much movement while the finger is in contact with the screen - and decide not to fire a <code>click</code> or <code>contextmenu</code> event. These aspects of user agent behavior are not defined in this specification, and they may differ between implementations.</p>
        </div>
        <p>Unless otherwise noted, the target of any mapped mouse event SHOULD be the same target as the respective pointer event unless the target is no longer participating in its <code>ownerDocument</code>'s tree. In this case, the mouse event should be fired at the original target's nearest ancestor node (at the time it was removed from the tree) that still participates in its <code>ownerDocument</code>'s tree, meaning that a new event path (based on the new target node) is built for the mouse event.</p>
        <p>Authors can prevent the production of certain compatibility mouse events by canceling the <code>pointerdown</code> event. </p>
        <div class="note">Mouse events can only be prevented when the pointer is down.  Hovering pointers (e.g. a mouse with no buttons pressed) cannot have their mouse events prevented. And, the <code>mouseover</code>, <code>mouseout</code>, <code>mouseenter</code>, and <code>mouseleave</code> events are never prevented (even if the pointer is down).</div>
        <section>
            <h2><dfn>Tracking the effective position of the legacy mouse pointer</dfn></h2>
            <p>While only the <a data-lt="Primary Pointer">primary pointers</a> can produce compatibility mouse events, <a href="#multiple-primary-pointers">multiple primary pointers</a> can be active simultaneously, each producing its own compatibility mouse events.  Since all these compatibility events would appear to MouseEvent code to be coming from a single mouse device, user agents are encouraged to guarantee that the compatibility mouse events are consistent from a single device perspective.  For mouse transition events (i.e., <code>mouseover</code>, <code>mouseout</code>, <code>mouseenter</code> and <code>mouseleave</code>), this means the entry/exit state for every event target is valid as implied by [[UIEVENTS]].  Users agents SHOULD guarantee this by maintaining the <dfn>effective position of the legacy mouse pointer</dfn> in the document as follows.</p>
            <p>Right before firing a <code>pointerdown</code>, <code>pointerup</code> or <code>pointermove</code> event, or a <code>pointerleave</code> event at the <code>window</code>, the user agent SHOULD run the following steps:</p>
            <ol>
                <li>Let |T| be the target of the <code>pointerdown</code>, <code>pointerup</code> or <code>pointermove</code> event being dispatched. For the <code>pointerleave</code> event, unset |T|.</li>
                <li>If |T| and current <a data-lt="effective position of the legacy mouse pointer">effective legacy mouse pointer position</a> are both unset or they are equal, terminate these steps.</li>
                <li>Dispatch <code>mouseover</code>, <code>mouseout</code>, <code>mouseenter</code> and <code>mouseleave</code> events as per [[UIEVENTS]] for a mouse moving from the current <a data-lt="effective position of the legacy mouse pointer">effective legacy mouse pointer position</a> to |T|. Consider an unset value of either current <a data-lt="effective position of the legacy mouse pointer">effective legacy mouse pointer position</a> or |T| as an out-of-window mouse position.</li>
                <li>Set <a data-lt="effective position of the legacy mouse pointer">effective legacy mouse pointer position</a> to |T|.</li>
            </ol>
        </section>
        <section>
            <h2>Mapping for devices that support hover</h2>
            <p>Whenever a user agent is to dispatch a pointer event for a device that supports hover, it SHOULD run the following steps:</p>
            <ol>
                <li>If the <code>isPrimary</code> property for the pointer event to be dispatched is <code>false</code> then dispatch the pointer event and terminate these steps.</li>
                <li>If the pointer event to be dispatched is a <code>pointerdown</code>, <code>pointerup</code> or <code>pointermove</code> event, or a <code>pointerleave</code> event at the <code>window</code>, dispatch compatibility mouse transition events as described in <a>Tracking the effective position of the legacy mouse pointer</a>.</li>
                <li>Dispatch the pointer event.</li>
                <li>If the pointer event dispatched was <code>pointerdown</code> and the event was <a data-lt="canceled event">canceled</a>, then set the <code>PREVENT MOUSE EVENT</code> flag for this <code>pointerType</code>.</li>
                <li>If the <code>PREVENT MOUSE EVENT</code> flag is <strong>not</strong> set for this <code>pointerType</code> and the pointer event dispatched was:
                    <ul>
                        <li><code>pointerdown</code>, then fire a <code>mousedown</code> event.</li>
                        <li><code>pointermove</code>, then fire a <code>mousemove</code> event.</li>
                        <li><code>pointerup</code>, then fire a <code>mouseup</code> event.</li>
                        <li><code>pointercancel</code>, then fire a <code>mouseup</code> event at the <code>window</code>.</li>
                    </ul>
                </li>
                <li>If the pointer event dispatched was <code>pointerup</code> or <code>pointercancel</code>, clear the <code>PREVENT MOUSE EVENT</code> flag for this <code>pointerType</code>.</li>
            </ol>
        </section>
        <section>
            <h2>Mapping for devices that do not support hover</h2>
            <p>Some devices, such as most touchscreens, do not support hovering a coordinate (or set of coordinates) while not in the active state. Much existing content coded to mouse events assumes that a mouse is producing the events and thus certain qualities are generally true:</p>
            <ul>
                <li>The input can hover independently of activation (e.g. moving a mouse cursor without any buttons pressed).</li>
                <li>The input will likely produce the <code>mousemove</code> event on an element before clicking it.</li>
            </ul>
            <div class="note">Hover is sometimes used to toggle the visibility of UI elements in content designed for mouse (e.g. "hover menus"). This content is often incompatible with <a href=#mapping-for-devices-that-do-not-support-hover>devices that do not support hover</a>. This specification does not define a mapping or behavior for compatibility with this scenario. It will be considered in a future version of the specification.</div>
            <p>This requires that user agents provide a different mapping for these types of input devices. Whenever a user agent is to dispatch a pointer event for a device that <a href=#mapping-for-devices-that-do-not-support-hover>does not support hover</a>, it SHOULD run the following steps:</p>
            <ol>
                <li>If the <code>isPrimary</code> property for the pointer event to be dispatched is <code>false</code> then dispatch the pointer event and terminate these steps.</li>
                <li>If the pointer event to be dispatched is <code>pointerover</code> and the <code>pointerdown</code> event has not yet been dispatched for this pointer, then fire a <code>mousemove</code> event (for compatibility with legacy mouse-specific code).</li>
                <li>If the pointer event to be is dispatched is a <code>pointerdown</code>, <code>pointerup</code> or <code>pointermove</code> event, or a <code>pointerleave</code> event at the <code>window</code>, dispatch compatibility mouse transition events as described in <a>Tracking the effective position of the legacy mouse pointer</a>.</li>
                <li>Dispatch the pointer event.</li>
                <li>If the pointer event dispatched was <code>pointerdown</code> and the event was <a data-lt="canceled event">canceled</a>, then set the <code>PREVENT MOUSE EVENT</code> flag for this <code>pointerType</code>.</li>
                <li>If the <code>PREVENT MOUSE EVENT</code> flag is <strong>not</strong> set for this <code>pointerType</code> and the pointer event dispatched was:
                    <ul>
                        <li><code>pointerdown</code>, then fire a <code>mousedown</code> event.</li>
                        <li><code>pointermove</code>, then fire a <code>mousemove</code> event.</li>
                        <li><code>pointerup</code>, then fire a <code>mouseup</code> event.</li>
                        <li><code>pointercancel</code>, then fire a <code>mouseup</code> event at the <code>window</code>.</li>
                    </ul>
                </li>
                <li>If the pointer event dispatched was <code>pointerup</code> or <code>pointercancel</code>, clear the <code>PREVENT MOUSE EVENT</code> flag for this <code>pointerType</code>.</li>
            </ol>
            <div class="note">
                <p>If the user agent supports both Touch Events (as defined in [[TOUCH-EVENTS]]) and Pointer Events, the user agent SHOULD NOT generate compatibility mouse events as described in this section as it is likely to introduce compatibility problems for sites that expect mouse events to be generated in accordance with the <a data-cite="touch-events/#mouse-events">model</a> outlined in [[TOUCH-EVENTS]].</p>
            </div>
            <div class="note">
                <p>The activation of an element (<code>click</code>) with a primary pointer that <a href=#mapping-for-devices-that-do-not-support-hover>does not support hover</a> (e.g. single finger on a touchscreen) would typically produce the following event sequence:</p>
                <ol data-class="note-list">
                    <li><code>mousemove</code></li>
                    <li><code>pointerover</code></li>
                    <li><code>pointerenter</code></li>
                    <li><code>mouseover</code></li>
                    <li><code>mouseenter</code></li>
                    <li><code>pointerdown</code></li>
                    <li><code>mousedown</code></li>
                    <li>Zero or more <code>pointermove</code> and <code>mousemove</code> events, depending on movement of the pointer</li>
                    <li><code>pointerup</code></li>
                    <li><code>mouseup</code></li>
                    <li><code>click</code></li>
                    <li><code>pointerout</code></li>
                    <li><code>pointerleave</code></li>
                    <li><code>mouseout</code></li>
                    <li><code>mouseleave</code></li>
                </ol>
                <p>If, however, the <code>pointerdown</code> event is <a data-lt="canceled event">canceled</a> during this interaction then the sequence of events would be:</p>
                <ol data-class="note-list">
                    <li><code>mousemove</code></li>
                    <li><code>pointerover</code></li>
                    <li><code>pointerenter</code></li>
                    <li><code>mouseover</code></li>
                    <li><code>mouseenter</code></li>
                    <li><code>pointerdown</code></li>
                    <li>Zero or more <code>pointermove</code> events, depending on movement of the pointer</li>
                    <li><code>pointerup</code></li>
                    <li><code>click</code></li>
                    <li><code>pointerout</code></li>
                    <li><code>pointerleave</code></li>
                    <li><code>mouseout</code></li>
                    <li><code>mouseleave</code></li>
                </ol>
            </div>
        </section>
    </section>
    <section class='informative'>
        <h2>Converting between <code>tiltX</code> / <code>tiltY</code> and <code>altitudeAngle</code> / <code>azimuthAngle</code></h2>
        <p>Depending on the specific hardware and platform, user agents will likely only receive one set of values for the transducer orientation relative to the screen plane - either <code>tiltX</code> / <code>tiltY</code> or <code>altitudeAngle</code> / <code>azimuthAngle</code>. The following basic code provides an initial suggested approach for converting these values.</p>
        <pre id="example_12" class="example" title="Converting between tiltX/tiltY and altitudeAngle/azimuthAngle"><code>/* Converting between tiltX/tiltY and altitudeAngle/azimuthAngle */

function spherical2tilt(altitudeAngle, azimuthAngle){
  const radToDeg = 180/Math.PI;

  let tiltXrad = 0;
  let tiltYrad = 0;

  if(altitudeAngle == 0){
    // the pen is in the X-Y plane
    if(azimuthAngle == 0 || azimuthAngle == 2*Math.PI){
      // pen is on positive X axis
      tiltXrad = Math.PI/2;
    }
    if(azimuthAngle == Math.PI/2){
      // pen is on positive Y axis
      tiltYrad = Math.PI/2;
    }
    if(azimuthAngle == Math.PI){
      // pen is on negative X axis
      tiltXrad = -Math.PI/2;
    }
    if(azimuthAngle == 3*Math.PI/2){
      // pen is on negative Y axis
      tiltYrad = -Math.PI/2;
    }
    if(azimuthAngle&gt;0 && azimuthAngle&lt;Math.PI/2){
      tiltXrad = Math.PI/2;
      tiltYrad = Math.PI/2;
    }
    if(azimuthAngle&gt;Math.PI/2 && azimuthAngle&lt;Math.PI){
      tiltXrad = -Math.PI/2;
      tiltYrad = Math.PI/2;
    }
    if(azimuthAngle&gt;Math.PI && azimuthAngle&lt;3*Math.PI/2){
      tiltXrad = -Math.PI/2;
      tiltYrad = -Math.PI/2;
    }
    if(azimuthAngle&gt;3*Math.PI/2 && azimuthAngle&lt;2*Math.PI){
      tiltXrad = Math.PI/2;
      tiltYrad = -Math.PI/2;
    }
  }

  if(altitudeAngle != 0){
    const tanAlt = Math.tan(altitudeAngle);

    tiltXrad = Math.atan(Math.cos(azimuthAngle) / tanAlt);
    tiltYrad = Math.atan(Math.sin(azimuthAngle) / tanAlt);
  }

  return {"tiltX":tiltXrad*radToDeg, "tiltY":tiltYrad*radToDeg};
}

function tilt2spherical(tiltX, tiltY){
  const tiltXrad = tiltX * Math.PI/180;
  const tiltYrad = tiltY * Math.PI/180;

  // calculate azimuth angle
  let azimuthAngle = 0;

  if(tiltX == 0){
    if(tiltY &gt; 0){
      azimuthAngle = Math.PI/2;
    }
    else if(tiltY &lt; 0){
      azimuthAngle = 3*Math.PI/2;
    }
  } else if(tiltY == 0){
    if(tiltX &lt; 0){
      azimuthAngle = Math.PI;
    }
  } else if(Math.abs(tiltX) == 90 || Math.abs(tiltY) == 90){
    // not enough information to calculate azimuth
    azimuthAngle = 0;
  } else {
    // Non-boundary case: neither tiltX nor tiltY is equal to 0 or +-90
    const tanX = Math.tan(tiltXrad);
    const tanY = Math.tan(tiltYrad);

    azimuthAngle = Math.atan2(tanY, tanX);
    if(azimuthAngle &lt; 0){
      azimuthAngle += 2*Math.PI;
    }
  }

  // calculate altitude angle
  let altitudeAngle = 0;

  if (Math.abs(tiltX) == 90 || Math.abs(tiltY) == 90){
      altitudeAngle = 0
  } else if (tiltX == 0){
    altitudeAngle = Math.PI/2 - Math.abs(tiltYrad);
  } else if(tiltY == 0){
    altitudeAngle = Math.PI/2 - Math.abs(tiltXrad);
  } else {
    // Non-boundary case: neither tiltX nor tiltY is equal to 0 or +-90
    altitudeAngle =  Math.atan(1.0/Math.sqrt(Math.pow(Math.tan(tiltXrad),2) + Math.pow(Math.tan(tiltYrad),2)));
  }

  return {"altitudeAngle":altitudeAngle, "azimuthAngle":azimuthAngle};
}</code>
</pre>
    </section>
    <section>
        <h2>Security and privacy considerations</h2>
        <p>This appendix discusses security and privacy considerations for Pointer Events implementations. The discussion is limited to security and privacy issues that arise directly from implementation of the event model, APIs and events defined in this specification.</p>
        <p>Many of the event types defined in this specification are dispatched in response to user actions. This allows malicious event listeners to gain access to information users would typically consider confidential, e.g., the exact path/movement of a user's mouse/stylus/finger while interacting with a page.</p>
        <p>Pointer events contain additional information (where supported by the user's device), such as the angle or tilt at which a pen input is held, the geometry of the contact surface, and the pressure exerted on the stylus or touch screen. Information about angle, tilt, geometry and pressure are directly related to sensors on the user's device, meaning that this specification allows an origin access to these sensors.</p>
        <p>This sensor data, as well as the ability to determine the type of input mechanism (mouse, touch, pen) used, may be used to infer characteristics of a user, or of the user's device and environment. These inferred characteristics and any device/environment information may themselves be sensitive - for instance, they may allow a malicious site to further infer if a user is using assistive technologies. This information can also be potentially used for the purposes of building a user profile and/or attempting to "fingerprint" and track a particular user.</p>
        <p>As mitigation, user agents may consider including the ability for users to disable access to particular sensor data (such as angle, tilt, pressure), and/or to make it available only after an explicit opt-in from the user.</p>
        <p>Beyond these considerations, the working group believes that this specification:</p>
        <ul>
            <li>Does not expose personally-identifiable information.</li>
            <li>Does not deal with high-value data.</li>
            <li>Does not introduce new state for an origin that persists across browsing sessions.</li>
            <li>Does not expose persistent, cross-origin state to the web.</li>
            <li>Does not expose any other data to an origin that it doesn’t currently have access to.</li>
            <li>Does not enable new script execution/loading mechanisms.</li>
            <li>Does not allow an origin access to a user’s location.</li>
            <li>Does not require any special handling when the user agent is in "incognito" mode.</li>
            <li>Does not allow an origin access to other devices.</li>
            <li>Does not allow an origin control over a user agent’s native UI.</li>
            <li>Does not expose temporary identifiers to the web.</li>
            <li>Does not distinguish between behavior in first-party and third-party contexts.</li>
            <li>Does not persist data to a user’s local device.</li>
            <li>Does not allow downgrading default security characteristics.</li>
        </ul>
    </section>
    <section class="informative">
        <h1>Glossary</h1>
        <dl>
            <dt><dfn>active buttons state</dfn></dt>
                <dd>The condition when a pointer has a non-zero value for the <code>buttons</code> property. For mouse, this is when the device has at least one button depressed. For touch, this is when there is physical contact with the digitizer. For pen, this is when either the pen has physical contact with the digitizer, or at least one button is depressed while hovering.</dd>
            <dt><dfn>active document</dfn></dt>
                <dd>For every <a>active pointer</a>, the document that received the last event from that pointer.</dd>
            <dt><dfn>active pointer</dfn></dt>
                <dd>Any touch contact, pen/stylus, mouse cursor, or other pointer that can produce events. If it is possible for a given pointer (identified by a unique <code>pointerId</code>) to produce additional events within the document, then that pointer is still considered active. Examples:
                    <ul>
                        <li>A mouse connected to the device is always active.</li>
                        <li>A touch contact on the screen is considered active.</li>
                        <li>If a touch contact or pen/stylus is lifted beyond the range of the digitizer, then it is no longer considered active.</li>
                    </ul>
                    <div class="note">On some platforms, the set of active pointers includes all pointer input to the device, including any that are not targeted at the user agent (e.g. those targeted at other applications).</div>
                    <div class="note">Each active pointer should have the same id within the scope of the <a>top-level browsing context</a> (as defined by [[HTML]]). However, there is no such guarantee across multiple <a>top-level browsing contexts</a>. </div>
                </dd>
            <dt><dfn>canceled event</dfn></dt>
                <dd>An event whose default action was prevented by means of <code>preventDefault()</code>, returning <code>false</code> in an event handler, or other means as defined by [[UIEVENTS]] and [[HTML]].</dd>
            <dt><dfn>contact geometry</dfn></dt>
                <dd>The bounding box of an input (most commonly, touch) on a digitizer. This typically refers to devices with coarser pointer input resolution than a single pixel. Some devices do not report this data at all.</dd>
            <dt><dfn>digitizer</dfn></dt>
                <dd>A type of input sensing device in which a surface can detect input which is in contact and/or in close proximity. Most commonly, this is the surface that senses input from the touch contact or a pen/stylus.</dd>
            <dt><dfn>direct manipulation</dfn></dt>
                <dd>Certain user agents (such as browsers on a touchscreen device) implement a "direct manipulation" metaphor where a pointer not only interacts with controls, but
                is also used to directly pan or zoom the current page, providing the illusion of direct physical contact. As an example, users on a touchscreen device are generally
                able to use a finger or a stylus to "grab" a page and pan it by moving the pointer, directly manipulating the page. Contrast this with a mouse pointer on a regular
                desktop/laptop, where panning is done by using a scrollbar, rather than by "dragging" the page.
                <div class="note">In some cases, touchpads (like those found on a laptop) will allow the user to scroll by "dragging" on the touchpad. However, this is generally achieved
                by the touchpad generating "fake" mouse wheel events, so this wouldn't count as a direct manipulation.</div>
                </dd>
            <dt><dfn>hit test</dfn></dt>
                <dd>The process by which a user agent determines a target element for a pointer event. Typically, this is determined by considering the pointer's location and also the visual layout of elements in a document on screen media.</dd>
            <dt><dfn>measurable properties</dfn></dt>
                <dd><p>Measurable properties represent values relating to continuous pointer sensor data that is expressed using a real number or an
                    integer from a large domain. For pointer events, <code>width</code>, <code>height</code>, <code>pressure</code>,
                    <code>tangentialPressure</code>, <code>tiltX</code>, <code>tiltY</code>, <code>twist</code>,
                    <code>altitudeAngle</code>, <code>azimuthAngle</code>, and the [[UI-EVENTS]] Mouse Event model properties
                    <code>screenX</code>, <code>screenY</code>, <code>clientX</code>, <code>clientY</code> are measurable properties.</p>
                    <p>In contrast <code>pointerId</code>, <code>pointerType</code>, <code>isPrimary</code>, and the
                    [[UI-EVENTS]] Mouse Event model properties <code>button</code>, <code>buttons</code>, <code>ctrlKey</code>,
                    <code>shiftKey</code>, <code>altKey</code>, and <code>metaKey</code> are not considered measurable properties,
                    as they don't relate to sensor data.</p>
                    </dd>
            <dt><dfn>pointer</dfn></dt>
                <dd>A hardware agnostic representation of input devices that can target a specific coordinate (or set of coordinates) on a screen, such as a mouse, pen, or touch contact.</dd>
            <dt><dfn>user agent</dfn></dt>
                <dd>A program, such as a browser or content authoring tool, normally running on a client machine, which acts on a user's behalf in retrieving, interpreting, executing, presenting, or creating content.</dd>
        </dl>
    </section>
    <section class="appendix">
        <h1>Acknowledgments</h1>
        <p>Many thanks to lots of people for their proposals and recommendations, some of which are incorporated into this document. The group's Chair acknowledges contributions from the following past and present group members and participants:
            Mustaq Ahmed,
            Arthur Barstow,
            Matt Brubeck,
            Rick Byers,
            Marcos Cáceres,
            Cathy Chan,
            Bo Cupp,
            Domenic Denicola,
            Ted Dinklocker,
            Robert Flack,
            Dave Fleck,
            Ella Ge,
            Scott González,
            Kartikaya Gupta,
            Philippe Le Hégaret,
            Hayato Ito,
            Patrick Kettner,
            Patrick H. Lauke,
            Scott Low,
            Sangwhan Moon,
            Olli Pettay,
            Antoine Quint,
            Jacob Rossi,
            Kagami Sascha Rosylight,
            Doug Schepers,
            Ming-Chou Shih,
            Brenton Simpson,
            Dave Tapuska,
            Liviu Tinta,
            Asir Vedamuthu,
            Lan Wei,
            Navid Zolghadr
        </p>
        <p>Special thanks to those that helped pioneer the first edition of this model, including especially: Charu Chandiram, Peter Freiling, Nathan Furtwangler, Thomas Olsen, Matt Rakow, Ramu Ramanathan, Justin Rogers, Jacob Rossi, Reed Townsend and Steve Wright.</p>
    </section>
    <section class="appendix informative">
        <h1>Revision history</h1>
        <p>The following is an informative summary of substantial and major editorial changes between publications of this specification, relative to the [[PointerEvents2]] specification.
           See the <a href="https://github.com/w3c/pointerevents/commits">complete revision history of the Editor's Drafts of this specification</a>.</p>
        <ul>
            <li><a href="https://github.com/w3c/pointerevents/pull/376">Clarify the rationale and purpose of <code>touch-action</code></a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/364">Add new section explaining coalesced and predicted events</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/351">Add a SHOULD clause about pan gestures and what happens if a gesture suddenly changes direction</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/350">Major refactoring: refer to "direct manipulation" rather than "touch"</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/349">Reword/expand <code>touch-action</code> definition</a> (scope it clearly to just panning/zooming actions)</li>
            <li><a href="https://github.com/w3c/pointerevents/pull/348">Add more info to note about <code>click</code>/<code>contextmenu</code> and user agent heuristics</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/347">Reword note about primary/non-primary pointers</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/345">Change reserved <code>pointerId</code> for non-pointer events from <code>0</code> to <code>-1</code></a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/334">Add note about <code>touch-action</code> and iframe/embedded browsing contexts</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/324">Fix tilt to spherical calculation</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/323">Update <code>azimuthAngle</code>, <code>altitudeAngle</code>, <code>tiltX</code>, <code>tiltY</code> to not require default values in pointer events web IDL</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/318">Add secure context criteria to <code>pointerrawupdate</code> and <code>getCoalescedEvents</code></a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/317">Change the type of <code>click</code>, <code>auxclick</code>, and <code>contextmenu</code> to PointerEvent</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/316">Add <code>altitudeAngle</code>/<code>azimuthAngle</code></a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/307">Add <code>getPredictedEvents</code> API.</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/306">Introduce <code>getCoalescedEvents</code> API, <code>pointerrawupdate</code> event.</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/300">Clarify active document for active pointers.</a></li>
            <li><a href="https://github.com/w3c/pointerevents/pull/294">Add direction-specific <code>touch-action</code> values</a>
                (<code>pan-left</code>, <code>pan-right</code>, <code>pan-up</code>, <code>pan-down</code>) and
                clarified behavior of existing <code>pan-x</code> and <code>pan-y</code> values.</li>
        </ul>
    </section>
    <!-- appendix -->
  </body>
</html>
